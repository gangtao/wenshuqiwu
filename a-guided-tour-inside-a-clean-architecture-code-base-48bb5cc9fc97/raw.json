[{
  "tag": "H2",
  "text": "mrsegev/MovieNight",
  "translation": "mrsegev /ç”µå½±ä¹‹å¤œ"
}, {
  "tag": "H3",
  "text": "MovieNight is a sample Android application that uses the clean architecture approach and is written in Kotlin.",
  "translation": "MovieNightæ˜¯ä½¿ç”¨å¹²å‡€æ¶æ„æ–¹æ³•çš„ç¤ºä¾‹Androidåº”ç”¨ç¨‹åºï¼Œç”±Kotlinç¼–å†™ã€‚"
}, {
  "tag": "H1",
  "text": "A Guided Tour inside a clean architecture code base.",
  "translation": "å¹²å‡€çš„ä½“ç³»ç»“æ„ä»£ç åº“å†…çš„å¯¼è§ˆã€‚"
}, {
  "tag": "P",
  "text": "Recently, I released an open-source sample project called MovieNight.In the past couple of weeks, I got lots of questions regarding the application architecture, so Iâ€™ve decided to write this blog post. Iâ€™ll describe the different components at play and the relationships between them as well as talk about some of the architecture decisions Iâ€™ve made along the way.",
  "translation": "æœ€è¿‘ï¼Œæˆ‘å‘å¸ƒäº†ä¸€ä¸ªåä¸ºMovieNightçš„å¼€æºç¤ºä¾‹é¡¹ç›®ã€‚åœ¨è¿‡å»çš„å‡ å‘¨ä¸­ï¼Œæˆ‘å¯¹åº”ç”¨ç¨‹åºä½“ç³»ç»“æ„æœ‰å¾ˆå¤šç–‘é—®ï¼Œå› æ­¤ï¼Œæˆ‘å†³å®šæ’°å†™æ­¤åšå®¢æ–‡ç« ã€‚ æˆ‘å°†æè¿°æ­£åœ¨ä½¿ç”¨çš„ä¸åŒç»„ä»¶ä»¥åŠå®ƒä»¬ä¹‹é—´çš„å…³ç³»ï¼Œå¹¶è®¨è®ºæˆ‘åœ¨æ­¤è¿‡ç¨‹ä¸­åšå‡ºçš„ä¸€äº›æ¶æ„å†³ç­–ã€‚"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*EmLGzlmVEpy2wHroiE5ZbA.jpeg?q=20",
  "caption": "Photo by Chris Lawton on Unsplash",
  "type": "image",
  "file": "1*EmLGzlmVEpy2wHroiE5ZbA.jpeg"
}, {
  "tag": "P",
  "text": "Iâ€™ll do my best to highlight the more interesting parts of the code base, but thereâ€™s so much I can write about in a single post. If you find the topic interesting, I recommend that youâ€™ll clone the project and explore the code base by yourself.",
  "translation": "æˆ‘ä¼šå°½åŠ›çªå‡ºä»£ç åº“ä¸­æ›´æœ‰è¶£çš„éƒ¨åˆ†ï¼Œä½†æ˜¯æˆ‘å¯ä»¥åœ¨ä¸€ç¯‡æ–‡ç« ä¸­å†™å¾ˆå¤šä¸œè¥¿ã€‚ å¦‚æœæ‚¨å‘ç°æœ‰è¶£çš„ä¸»é¢˜ï¼Œå»ºè®®æ‚¨å…‹éš†é¡¹ç›®å¹¶äº²è‡ªæ¢ç´¢ä»£ç åº“ã€‚"
}, {
  "tag": "P",
  "text": "You can find the source code of MovieNight right here:",
  "translation": "æ‚¨å¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°MovieNightçš„æºä»£ç ï¼š"
}, {
  "tag": "H2",
  "text": "mrsegev/MovieNight",
  "translation": "mrsegev /ç”µå½±ä¹‹å¤œ"
}, {
  "tag": "H3",
  "text": "MovieNight is a sample Android application that uses the clean architecture approach and is written in Kotlin.",
  "translation": "MovieNightæ˜¯ä½¿ç”¨å¹²å‡€æ¶æ„æ–¹æ³•çš„ç¤ºä¾‹Androidåº”ç”¨ç¨‹åºï¼Œç”±Kotlinç¼–å†™ã€‚"
}, {
  "tag": "H2",
  "text": "Before we begin #1",
  "translation": "åœ¨å¼€å§‹ï¼ƒ1ä¹‹å‰"
}, {
  "tag": "P",
  "text": "This blog post assumes knowledge on the following topics: Kotlin, RxJava, dependency injection, and testing. I did my best to add links for further reading throughout the post. If you come across a subject youâ€™re not familiar with I encourage you to take a pause and read about it a bit. So we could stay on the same page.",
  "translation": "è¯¥åšå®¢æ–‡ç« å‡å®šæ‚¨å…·æœ‰ä»¥ä¸‹ä¸»é¢˜çš„çŸ¥è¯†ï¼šKotlinï¼ŒRxJavaï¼Œä¾èµ–é¡¹æ³¨å…¥å’Œæµ‹è¯•ã€‚ æˆ‘å°½åŠ›æ·»åŠ é“¾æ¥ï¼Œä»¥ä¾¿åœ¨æ•´ä¸ªå¸–å­ä¸­è¿›ä¸€æ­¥é˜…è¯»ã€‚ å¦‚æœæ‚¨ä¸ç†Ÿæ‚‰æŸä¸ªä¸»é¢˜ï¼Œå»ºè®®æ‚¨ç¨ä½œä¼‘æ¯ï¼Œç„¶åå†è¯»ä¸€è¯»ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥ç•™åœ¨åŒä¸€é¡µé¢ä¸Šã€‚"
}, {
  "tag": "H2",
  "text": "Before we begin #2",
  "translation": "åœ¨å¼€å§‹ï¼ƒ2ä¹‹å‰"
}, {
  "tag": "P",
  "text": "Take everything youâ€™re going to read with a grain of salt. Architecture, by its nature, is dynamic and ever-evolving. There is no such thing as â€œthe perfect architectureâ€, there are always several solutions to every problem. Keep in mind that every architecture decision is a trade-off.",
  "translation": "ä¸€ä¸ç‚¹é’±å¸¦èµ°æ‚¨è¦é˜…è¯»çš„æ‰€æœ‰å†…å®¹ã€‚ ä»æœ¬è´¨ä¸Šè®²ï¼Œå»ºç­‘æ˜¯åŠ¨æ€çš„å¹¶ä¸”ä¸æ–­å‘å±•ã€‚ æ²¡æœ‰â€œå®Œç¾çš„ä½“ç³»ç»“æ„â€ä¹‹ç±»çš„ä¸œè¥¿ï¼Œå¯¹äºæ¯ä¸ªé—®é¢˜æ€»æ˜¯æœ‰å‡ ç§è§£å†³æ–¹æ¡ˆã€‚ è¯·è®°ä½ï¼Œæ¯ä¸ªæ¶æ„å†³ç­–éƒ½æ˜¯ä¸€ä¸ªæƒè¡¡ã€‚"
}, {
  "tag": "P",
  "text": "Now, grab yourself a cup of coffee/tea/beer(?), make sure youâ€™ve got the source code in front of you, and let us begin.",
  "translation": "ç°åœ¨ï¼Œä¸ºè‡ªå·±å–æ¯å’–å•¡/èŒ¶/å•¤é…’ï¼ˆï¼Ÿï¼‰ï¼Œç¡®ä¿æ‚¨å·²ç»æŒæ¡äº†æºä»£ç ï¼Œç„¶åè®©æˆ‘ä»¬å¼€å§‹å§ã€‚"
}, {
  "tag": "H1",
  "text": "A Clean approach",
  "translation": "å¹²å‡€çš„æ–¹æ³•"
}, {
  "tag": "P",
  "text": "MovieNight architecture is heavily influenced by Uncle Bobâ€™s clean architecture. Understanding the principles behind the clean approach is key for our guided tour.",
  "translation": "MovieNightçš„æ¶æ„åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå—åˆ°Bobå”å”çš„ç®€æ´æ¶æ„çš„å½±å“ã€‚ ç†è§£æ¸…æ´æ–¹æ³•èƒŒåçš„åŸç†æ˜¯æˆ‘ä»¬å¯¼æ¸¸çš„å…³é”®ã€‚"
}, {
  "tag": "P",
  "text": "Although clean architecture can be a bit overwhelming at first look, itâ€™s pretty simple to comprehend once you understand whatâ€™s it all about.",
  "translation": "å°½ç®¡ä¹ä¸€çœ‹ï¼Œå¹²å‡€çš„æ¶æ„å¯èƒ½æœ‰ç‚¹è®©äººä¸çŸ¥æ‰€æªï¼Œä½†æ˜¯ä¸€æ—¦æ‚¨äº†è§£äº†æ‰€æœ‰å†…å®¹ï¼Œå°±å¾ˆå®¹æ˜“ç†è§£ã€‚"
}, {
  "tag": "P",
  "text": "The core principles of the clean approach can be summarized as followed:",
  "translation": "æ¸…æ´æ–¹æ³•çš„æ ¸å¿ƒåŸåˆ™å¯æ€»ç»“å¦‚ä¸‹ï¼š"
}, {
  "tag": "UL",
  "texts": ["The application code is separated into layers.These layers define the separation of concerns inside the code base.", "The layers follow a strict dependency rule.Each layer can only interact with the layers below it.", "As we move toward the bottom layer â€” the code becomes generic.The bottom layers dictate policies and rules, and the upper layers dictate implementation details such as the database, networking manager, and UI."],
  "translations": ["åº”ç”¨ç¨‹åºä»£ç åˆ†ä¸ºå‡ å±‚ï¼Œè¿™äº›å±‚å®šä¹‰äº†ä»£ç åº“å†…éƒ¨å…³æ³¨ç‚¹çš„åˆ†ç¦»ã€‚", "è¿™äº›å±‚éµå¾ªä¸¥æ ¼çš„ä¾èµ–å…³ç³»è§„åˆ™ï¼Œæ¯ä¸ªå±‚åªèƒ½ä¸å…¶ä¸‹é¢çš„å±‚è¿›è¡Œäº¤äº’ã€‚", "éšç€æˆ‘ä»¬è¿›å…¥åº•å±‚ï¼Œä»£ç å˜å¾—é€šç”¨ã€‚åº•å±‚æŒ‡ç¤ºç­–ç•¥å’Œè§„åˆ™ï¼Œé«˜å±‚æŒ‡ç¤ºå®ç°ç»†èŠ‚ï¼Œä¾‹å¦‚æ•°æ®åº“ï¼Œç½‘ç»œç®¡ç†å™¨å’ŒUIã€‚"]
}, {
  "tag": "P",
  "text": "Consider the following abstract example:",
  "translation": "è€ƒè™‘ä»¥ä¸‹æŠ½è±¡ç¤ºä¾‹ï¼š"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*1PMsHT9L_fQeLmoX_qb9Lw.jpeg?q=20",
  "caption": "Dependencies flow between the layers.",
  "type": "image",
  "file": "1*1PMsHT9L_fQeLmoX_qb9Lw.jpeg"
}, {
  "tag": "UL",
  "texts": ["Layer C has access to layers B and A.", "Layer B has access to everything inside layer A but is unaware of anything inside layer C. In fact, layer B doesnâ€™t even know that layer C exists.", "Layer A is at the very bottom, sheâ€™s unaware of anything outside of her scope, and as weâ€™ll see soon enough, her ignorance truly is a bliss."],
  "translations": ["Cå±‚å¯ä»¥è®¿é—®Bå±‚å’ŒAå±‚ã€‚", "Bå±‚å¯ä»¥è®¿é—®Aå±‚ä¸­çš„æ‰€æœ‰å†…å®¹ï¼Œä½†ä¸çŸ¥é“Cå±‚ä¸­çš„ä»»ä½•å†…å®¹ã€‚å®é™…ä¸Šï¼ŒBå±‚ç”šè‡³ä¸çŸ¥é“Cå±‚å­˜åœ¨ã€‚", "Aå±‚ä½äºæœ€åº•å±‚ï¼Œå¥¹æ²¡æœ‰æ„è¯†åˆ°è‡ªå·±èŒƒå›´ä»¥å¤–çš„ä»»ä½•äº‹ç‰©ï¼Œè€Œä¸”æˆ‘ä»¬å¾ˆå¿«å°±ä¼šå‘ç°ï¼Œå¥¹çš„æ— çŸ¥ç¡®å®æ˜¯ä¸€ç§å¹¸ç¦ã€‚"]
}, {
  "tag": "P",
  "text": "Thatâ€™s it. Every other architectural detail exists only to serve these core principles.",
  "translation": "è€Œå·²ã€‚ å…¶ä»–æ‰€æœ‰æ¶æ„ç»†èŠ‚éƒ½ä»…ç”¨äºæœåŠ¡è¿™äº›æ ¸å¿ƒåŸåˆ™ã€‚"
}, {
  "tag": "H2",
  "text": "Why use the clean approach?",
  "translation": "ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å¹²å‡€çš„æ–¹æ³•ï¼Ÿ"
}, {
  "tag": "P",
  "text": "Did you ever had the â€œpleasureâ€ of replacing in-memory, synchronized data store with an asynchronous, fully-fledged database? ğŸ˜°",
  "translation": "æ‚¨æ˜¯å¦æ›¾ç»æœ‰è¿‡ç”¨å†…ç½®çš„å¼‚æ­¥æ•°æ®åº“æ›¿æ¢å†…å­˜ä¸­åŒæ­¥æ•°æ®å­˜å‚¨çš„â€œä¹è¶£â€ï¼Ÿ ğŸ˜°"
}, {
  "tag": "P",
  "text": "Requirements will change. The design will change. Basically, all the implementation details are heavily prone to change.By dividing the code into layers we can â€œpushâ€ these details into the upper layers, and by following the dependency rule, weâ€™re able to isolate them from the core functionality of our application.",
  "translation": "è¦æ±‚å°†æ”¹å˜ã€‚ è®¾è®¡å°†æ”¹å˜ã€‚ åŸºæœ¬ä¸Šï¼Œæ‰€æœ‰å®ç°ç»†èŠ‚éƒ½éå¸¸å®¹æ˜“å‘ç”Ÿæ›´æ”¹ã€‚é€šè¿‡å°†ä»£ç åˆ†æˆå‡ å±‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™äº›ç»†èŠ‚â€œæ¨â€åˆ°ä¸Šå±‚ï¼Œå¹¶ä¸”é€šè¿‡éµå¾ªä¾èµ–å…³ç³»è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬ä¸æˆ‘ä»¬çš„æ ¸å¿ƒåŠŸèƒ½éš”ç¦»å¼€æ¥ã€‚ åº”ç”¨ã€‚"
}, {
  "tag": "P",
  "text": "This isolation allows us to write code that is more testable and independent of any external factors, so when a change â€œhitsâ€ we can react to it quickly and efficiently without breaking too many walls.",
  "translation": "è¿™ç§éš”ç¦»ä½¿æˆ‘ä»¬èƒ½å¤Ÿç¼–å†™å¯æµ‹è¯•æ€§æ›´é«˜çš„ä»£ç ï¼Œå¹¶ä¸”ä¸å—ä»»ä½•å¤–éƒ¨å› ç´ çš„å½±å“ï¼Œå› æ­¤ï¼Œå½“å‘ç”Ÿæ›´æ”¹â€œå‘½ä¸­â€æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿï¼Œæœ‰æ•ˆåœ°å¯¹å®ƒåšå‡ºååº”ï¼Œè€Œä¸ä¼šç ´åå¤ªå¤šå£å’ã€‚"
}, {
  "tag": "P",
  "text": "Now that weâ€™re on the same page, we can take a look at MovieNight actual architecture layers.",
  "translation": "ç°åœ¨æˆ‘ä»¬åœ¨åŒä¸€é¡µä¸Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹MovieNightçš„å®é™…ä½“ç³»ç»“æ„å±‚ã€‚"
}, {
  "tag": "H1",
  "text": "MovieNight architecture layers",
  "translation": "MovieNightä½“ç³»ç»“æ„å±‚"
}, {
  "tag": "P",
  "text": "The application consists of three layers: The domain layer, the data layer, and the presentation layer.",
  "translation": "è¯¥åº”ç”¨ç¨‹åºåŒ…æ‹¬ä¸‰å±‚ï¼šåŸŸå±‚ï¼Œæ•°æ®å±‚å’Œè¡¨ç¤ºå±‚ã€‚"
}, {
  "tag": "P",
  "text": "Looking at MovieNightâ€™s high-level project structure, youâ€™ll see that each layer is represented by a module in the project.",
  "translation": "æŸ¥çœ‹MovieNightçš„é«˜çº§é¡¹ç›®ç»“æ„ï¼Œæ‚¨ä¼šçœ‹åˆ°æ¯ä¸ªå±‚éƒ½ç”±é¡¹ç›®ä¸­çš„æ¨¡å—è¡¨ç¤ºã€‚"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*sUBTlhq9UfKJgykT8oKbDw.png?q=20",
  "caption": "MovieNight high-level project structure.",
  "type": "image",
  "file": "1*sUBTlhq9UfKJgykT8oKbDw.png"
}, {
  "tag": "P",
  "text": "Like everything in this article, this project structure is just one way of doing things. I like it because it helps me avoid accidentals â€œleaksâ€ between the layers as I must specify in each module build.gradle file which other modules (i.e., layers) it depends on.",
  "translation": "å°±åƒæœ¬æ–‡ä¸­çš„æ‰€æœ‰å†…å®¹ä¸€æ ·ï¼Œè¿™ç§é¡¹ç›®ç»“æ„åªæ˜¯åšäº‹çš„ä¸€ç§æ–¹å¼ã€‚ æˆ‘å–œæ¬¢å®ƒæ˜¯å› ä¸ºå®ƒå¯ä»¥å¸®åŠ©æˆ‘é¿å…å„å±‚ä¹‹é—´çš„æ„å¤–â€œæ³„æ¼â€ï¼Œå› ä¸ºæˆ‘å¿…é¡»åœ¨æ¯ä¸ªæ¨¡å—build.gradleæ–‡ä»¶ä¸­æŒ‡å®šå®ƒä¾èµ–äºå…¶ä»–æ¨¡å—ï¼ˆå³å„å±‚ï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "Hereâ€™s a high-level chart of the layers and what they hold:",
  "translation": "ä»¥ä¸‹æ˜¯å„å±‚åŠå…¶ç”¨é€”çš„é«˜çº§å›¾è¡¨ï¼š"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*3smlPZenpAtICXdgcjuHSg.jpeg?q=20",
  "caption": "MovieNight architecture layers.",
  "type": "image",
  "file": "1*3smlPZenpAtICXdgcjuHSg.jpeg"
}, {
  "tag": "P",
  "text": "If this chart looks a bit overwhelming right now â€” donâ€™t sweat it! ğŸ˜„Weâ€™ll explore each layer implementation details, and soon enough, everything will (hopefully) make sense.",
  "translation": "å¦‚æœè¿™å¼ å›¾è¡¨ç°åœ¨çœ‹èµ·æ¥æœ‰ç‚¹ä»¤äººä¸çŸ¥æ‰€æª-è¯·ä¸è¦å¤§æ±—æ·‹æ¼“ï¼ llæˆ‘ä»¬å°†æ¢ç´¢æ¯å±‚å®æ–½çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¾ˆå¿«ï¼Œä¸€åˆ‡éƒ½ä¼šï¼ˆå¸Œæœ›ï¼‰æœ‰æ„ä¹‰ã€‚"
}, {
  "tag": "P",
  "text": "Letâ€™s dive into each layer, starting from the very bottom â€” The domain layer.",
  "translation": "è®©æˆ‘ä»¬ä»æœ€åº•å±‚å¼€å§‹æ·±å…¥ç ”ç©¶æ¯ä¸€å±‚-åŸŸå±‚ã€‚"
}, {
  "tag": "H1",
  "text": "The Domain layer",
  "translation": "åŸŸå±‚"
}, {
  "tag": "P",
  "text": "The domain layer is the baseline of the application. Its purpose is to describe what the application is and what it can do (soon weâ€™ll see concrete examples to this statement). Remember the third clean approach principle we discussed? As we move toward the bottom layer â€” the code becomes generic.",
  "translation": "åŸŸå±‚æ˜¯åº”ç”¨ç¨‹åºçš„åŸºå‡†ã€‚ å…¶ç›®çš„æ˜¯æè¿°åº”ç”¨ç¨‹åºæ˜¯ä»€ä¹ˆä»¥åŠå®ƒå¯ä»¥åšä»€ä¹ˆï¼ˆå¾ˆå¿«æˆ‘ä»¬å°†çœ‹åˆ°æ­¤è¯­å¥çš„å…·ä½“ç¤ºä¾‹ï¼‰ã€‚ è¿˜è®°å¾—æˆ‘ä»¬è®¨è®ºçš„ç¬¬ä¸‰ä¸ªå¹²å‡€æ–¹æ³•åŸåˆ™å—ï¼Ÿ éšç€æˆ‘ä»¬èµ°å‘åº•å±‚ï¼Œä»£ç å˜å¾—é€šç”¨ã€‚"
}, {
  "tag": "P",
  "text": "Every piece of code here is as generic as code can be. Concrete implementations and details belong to the upper layers.Being at the bottom, the domain layer is unaware of anything else in the application to the point that the code here has nothing to do with the Android framework, itâ€™s just â€œpureâ€ Kotlin. Why? Because itâ€™s irrelevant to the purpose of the domain layer.",
  "translation": "è¿™é‡Œçš„æ¯ä¸€æ®µä»£ç éƒ½æ˜¯é€šç”¨çš„ã€‚ å…·ä½“çš„å®ç°å’Œç»†èŠ‚å±äºä¸Šå±‚ã€‚åœ¨åº•å±‚ï¼ŒåŸŸå±‚æ²¡æœ‰æ„è¯†åˆ°åº”ç”¨ç¨‹åºä¸­çš„ä»»ä½•å…¶ä»–å†…å®¹ï¼Œä»¥è‡´æ­¤å¤„çš„ä»£ç ä¸Androidæ¡†æ¶æ— å…³ï¼Œåªæ˜¯â€œçº¯â€çš„Kotlinã€‚ ä¸ºä»€ä¹ˆï¼Ÿ å› ä¸ºå®ƒä¸åŸŸå±‚çš„ç›®çš„æ— å…³ã€‚"
}, {
  "tag": "P",
  "text": "This layer holds mostly domain entities, interfaces and special classes called use cases.",
  "translation": "è¯¥å±‚ä¸»è¦åŒ…å«åŸŸå®ä½“ï¼Œæ¥å£å’Œç§°ä¸ºç”¨ä¾‹çš„ç‰¹æ®Šç±»ã€‚"
}, {
  "tag": "H2",
  "text": "Domain entities",
  "translation": "åŸŸå®ä½“"
}, {
  "tag": "P",
  "text": "These are the basic building blocks of our application and the ones that are least likely to change when something external changes. In the case of MovieNight, youâ€™ll find here classes such as MovieEntity and VideoEntity that describe the basic data structures we work with. Hereâ€™s the entities package:",
  "translation": "è¿™äº›æ˜¯æˆ‘ä»¬åº”ç”¨ç¨‹åºçš„åŸºæœ¬æ„å»ºå—ï¼Œå¹¶ä¸”æ˜¯åœ¨å¤–éƒ¨å‘ç”ŸæŸäº›æ›´æ”¹æ—¶æœ€ä¸å¯èƒ½æ›´æ”¹çš„æ„å»ºå—ã€‚ å¯¹äºMovieNightï¼Œæ‚¨ä¼šåœ¨æ­¤å¤„æ‰¾åˆ°æè¿°æˆ‘ä»¬ä½¿ç”¨çš„åŸºæœ¬æ•°æ®ç»“æ„çš„ç±»ï¼Œä¾‹å¦‚MovieEntityå’ŒVideoEntityã€‚ è¿™æ˜¯å®ä½“åŒ…è£…ï¼š"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*qZOZUZjVAX-I-5EORSwzOA.png?q=20",
  "caption": "MovieNight domain entities.",
  "type": "image",
  "file": "1*qZOZUZjVAX-I-5EORSwzOA.png"
}, {
  "tag": "P",
  "text": "This is part of what I meant when I wrote that the domain layer describes what the application is and what it can do: Looking at the entities package itâ€™s pretty clear what kind of data MovieNight is dealing with â€” movies, movies reviews, etc.",
  "translation": "è¿™æ˜¯æˆ‘å†™é¢†åŸŸå±‚æè¿°åº”ç”¨ç¨‹åºæ˜¯ä»€ä¹ˆä»¥åŠå®ƒå¯ä»¥åšä»€ä¹ˆçš„æ„æ€çš„ä¸€éƒ¨åˆ†ï¼šæŸ¥çœ‹å®ä½“åŒ…ï¼Œå¾ˆæ¸…æ¥šMovieNightå¤„ç†çš„æ˜¯å“ªç§æ•°æ®-ç”µå½±ï¼Œç”µå½±è¯„è®ºç­‰ã€‚"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/a4f7cb4be77c0137911805b7906b89fd/raw/1e628cc3aca23aee38231ebd24be79bb6ec01728/movienight-MovieEntity.kt",
  "code": "data class MovieEntity(\n\n        var id: Int = 0,\n        var title: String,\n        var overview: String? = null,\n        var voteCount: Int = 0\n        // ...\n)"
}, {
  "tag": "P",
  "text": "In our application case there is nothing fancy here, these classes just act as data containers, so I choose to create them as Kotlin data classes.",
  "translation": "åœ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºæ¡ˆä¾‹ä¸­ï¼Œè¿™é‡Œæ²¡æœ‰ä»€ä¹ˆå¹»æƒ³ï¼Œè¿™äº›ç±»ä»…å……å½“æ•°æ®å®¹å™¨ï¼Œå› æ­¤æˆ‘é€‰æ‹©å°†å®ƒä»¬åˆ›å»ºä¸ºKotlinæ•°æ®ç±»ã€‚"
}, {
  "tag": "H2",
  "text": "Use cases",
  "translation": "ç”¨ä¾‹"
}, {
  "tag": "P",
  "text": "Also known as interactors, a use case encapsulates a single, very specific task that can be performed. These use cases will later be used by the upper layers. Take a look at the use cases package:",
  "translation": "ç”¨ä¾‹ä¹Ÿç§°ä¸ºäº¤äº’å™¨ï¼Œå®ƒå°è£…äº†å¯ä»¥æ‰§è¡Œçš„å•ä¸ªéå¸¸ç‰¹å®šçš„ä»»åŠ¡ã€‚ è¿™äº›ç”¨ä¾‹ç¨åå°†ç”±ä¸Šå±‚ä½¿ç”¨ã€‚ çœ‹ä¸€ä¸‹ç”¨ä¾‹åŒ…ï¼š"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*nNYYtpoOntU-uT5xitHt_Q.png?q=20",
  "caption": "MovieNight use cases.",
  "type": "image",
  "file": "1*nNYYtpoOntU-uT5xitHt_Q.png"
}, {
  "tag": "P",
  "text": "Again, we describe the application. Just by looking at the files names its becomes obvious what the application can do: We can browse popular movies, we can manage favorite movies list, and we can search for movies.",
  "translation": "åŒæ ·ï¼Œæˆ‘ä»¬æè¿°åº”ç”¨ç¨‹åºã€‚ åªéœ€æŸ¥çœ‹æ–‡ä»¶åï¼Œå°±å¯ä»¥å¾ˆæ˜æ˜¾åœ°çœ‹å‡ºåº”ç”¨ç¨‹åºå¯ä»¥æ‰§è¡Œçš„æ“ä½œï¼šæˆ‘ä»¬å¯ä»¥æµè§ˆçƒ­é—¨ç”µå½±ï¼Œå¯ä»¥ç®¡ç†æ”¶è—çš„ç”µå½±åˆ—è¡¨ï¼Œè¿˜å¯ä»¥æœç´¢ç”µå½±ã€‚"
}, {
  "tag": "P",
  "text": "All the use cases extend the abstract UseCase class:",
  "translation": "æ‰€æœ‰ç”¨ä¾‹éƒ½æ‰©å±•äº†æŠ½è±¡ç”¨ä¾‹ç±»ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/50b8ad5d3c5d1220a315ed2bf85164bb/raw/5930c62dcd665dd1e357d34610ffc101a4ebf8f0/movienight-base-usecase.kt",
  "code": "abstract class UseCase<T>(private val transformer: Transformer<T>) {\n\n    abstract fun createObservable(data: Map<String, Any>? = null): Observable<T>\n\n    fun observable(withData: Map<String, Any>? = null): Observable<T> {\n        return createObservable(withData).compose(transformer)\n    }\n}"
}, {
  "tag": "P",
  "text": "And here is a more concrete use case that fetches popular movies:",
  "translation": "è¿™æ˜¯è·å–æµè¡Œç”µå½±çš„æ›´å…·ä½“çš„ç”¨ä¾‹ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/cff36f6a0316b864da6e95b94afc37e6/raw/fd25f5d858b71373a97251bddd1c070f2b7eec73/movienight-GetPopularMovies.kt",
  "code": "class GetPopularMovies(transformer: Transformer<List<MovieEntity>>,\n                       private val moviesRepository: MoviesRepository) : UseCase<List<MovieEntity>>(transformer) {\n  \n    override fun createObservable(data: Map<String, Any>?): Observable<List<MovieEntity>> {\n        return moviesRepository.getMovies()\n    }\n}"
}, {
  "tag": "P",
  "text": "There are few things worth mentioning here:",
  "translation": "è¿™é‡Œæœ‰å‡ ä»¶äº‹å€¼å¾—ä¸€æï¼š"
}, {
  "tag": "UL",
  "texts": ["The output of all use cases is an Observable.Not much else to say here. Observables allow us to write code in a more functional and reactive way, which I like.", "All use cases must receive a Transformer object in their constructor. The Transformer class is just a simple ObservableTransformer. Using a Transformer allows us to dynamically control on which threads the use case â€œruns.â€ Which makes it especially useful when writing tests, for example: when we fetch the list of popular movies we want it to run a worker thread and not clog the main thread, but when testing we want the code to run synchronously. It worth noting that other then for testing purposes, I canâ€™t think of any good reason to run the use cases on the main thread.", "We can pass optional data into the use case.Sometimes, we need some data passed into the use case, Kotlin optional and default values are useful here as we donâ€™t have to specify null values when the data is not needed."],
  "translations": ["æ‰€æœ‰ç”¨ä¾‹çš„è¾“å‡ºéƒ½æ˜¯å¯è§‚å¯Ÿçš„ï¼Œè¿™é‡Œæ²¡æœ‰å¤ªå¤šè¦è¯´çš„äº†ã€‚ å¯è§‚å¯Ÿå˜é‡ä½¿æˆ‘ä»¬èƒ½å¤Ÿä»¥ä¸€ç§æ›´å…·åŠŸèƒ½æ€§å’Œååº”æ€§çš„æ–¹å¼ç¼–å†™ä»£ç ï¼Œè¿™æ˜¯æˆ‘å–œæ¬¢çš„ã€‚", "æ‰€æœ‰ç”¨ä¾‹å¿…é¡»åœ¨å…¶æ„é€ å‡½æ•°ä¸­æ¥æ”¶ä¸€ä¸ªTransformerå¯¹è±¡ã€‚ Transformerç±»åªæ˜¯ä¸€ä¸ªç®€å•çš„ObservableTransformerã€‚ ä½¿ç”¨Transformerå¯ä»¥ä½¿æˆ‘ä»¬åŠ¨æ€æ§åˆ¶ç”¨ä¾‹åœ¨å“ªä¸ªçº¿ç¨‹ä¸Šè¿è¡Œã€‚è¿™åœ¨ç¼–å†™æµ‹è¯•æ—¶å°¤å…¶æœ‰ç”¨ï¼Œä¾‹å¦‚ï¼šå½“æˆ‘ä»¬è·å–æµè¡Œç”µå½±çš„åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒè¿è¡Œå·¥ä½œçº¿ç¨‹è€Œä¸æ˜¯é˜»å¡çº¿ç¨‹ã€‚ ä¸»çº¿ç¨‹ï¼Œä½†æ˜¯åœ¨æµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ä»£ç åŒæ­¥è¿è¡Œã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå‡ºäºæµ‹è¯•ç›®çš„ï¼Œæˆ‘æƒ³ä¸å‡ºæœ‰ä»€ä¹ˆå……åˆ†çš„ç†ç”±åœ¨ä¸»çº¿ç¨‹ä¸Šè¿è¡Œç”¨ä¾‹ã€‚", "æˆ‘ä»¬å¯ä»¥å°†å¯é€‰æ•°æ®ä¼ é€’åˆ°ç”¨ä¾‹ä¸­ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸€äº›æ•°æ®ä¼ é€’åˆ°ç”¨ä¾‹ä¸­ï¼ŒKotlinå¯é€‰å€¼å’Œé»˜è®¤å€¼åœ¨è¿™é‡Œå¾ˆæœ‰ç”¨ï¼Œå› ä¸ºåœ¨ä¸éœ€è¦æ•°æ®æ—¶ä¸å¿…æŒ‡å®šç©ºå€¼ã€‚"]
}, {
  "tag": "P",
  "text": "As you can see, GetPopularMovies use case received a MoviesRepository object when created, and that leads us to the next type of residents of the domain layer â€” interfaces.",
  "translation": "å¦‚æ‚¨æ‰€è§ï¼ŒGetPopularMoviesç”¨ä¾‹åœ¨åˆ›å»ºæ—¶æ”¶åˆ°äº†MoviesRepositoryå¯¹è±¡ï¼Œè¿™å°†æˆ‘ä»¬å¸¦åˆ°åŸŸå±‚çš„ä¸‹ä¸€ç§é©»ç•™ç±»å‹-æ¥å£ã€‚"
}, {
  "tag": "H2",
  "text": "Interfaces",
  "translation": "ä»‹é¢"
}, {
  "tag": "P",
  "text": "The domain layer interfaces dictate the contract the upper layers must follow. These abstractions ensure that the application core functionality will hold true, regardless of any implementation details changes. Letâ€™s take a look at GetPopularMovies use case again: when invoked, the use case returns an Observable that gets data from MoviesRepository.",
  "translation": "åŸŸå±‚æ¥å£è§„å®šäº†ä¸Šå±‚å¿…é¡»éµå¾ªçš„å¥‘çº¦ã€‚ è¿™äº›æŠ½è±¡ç¡®ä¿åº”ç”¨ç¨‹åºæ ¸å¿ƒåŠŸèƒ½å°†ä¿æŒæ­£ç¡®ï¼Œè€Œä¸ç®¡ä»»ä½•å®ç°ç»†èŠ‚æ›´æ”¹å¦‚ä½•ã€‚ è®©æˆ‘ä»¬å†æ¬¡çœ‹ä¸€ä¸‹GetPopularMoviesç”¨ä¾‹ï¼šè°ƒç”¨æ—¶ï¼Œç”¨ä¾‹è¿”å›ä¸€ä¸ªObservableï¼Œè¯¥Observableä»MoviesRepositoryè·å–æ•°æ®ã€‚"
}, {
  "tag": "P",
  "text": "Hereâ€™s MovieRepository implementation:",
  "translation": "è¿™æ˜¯MovieRepositoryçš„å®ç°ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/21560871dd415ede62077802348feb88/raw/35ac24a0f14569cc7752f140d1c5bd420171514d/movienight-moviesrepository.kt",
  "code": "interface MoviesRepository {\n    fun getMovies(): Observable<List<MovieEntity>>\n    fun search(query: String): Observable<List<MovieEntity>>\n    fun getMovie(movieId: Int): Observable<Optional<MovieEntity>>\n}"
}, {
  "tag": "P",
  "text": "Itâ€™s just an interface. Why? Because the implementation details of the repository are not relevant to the functionality of GetPopularMovies use case.",
  "translation": "è¿™åªæ˜¯ä¸€ä¸ªç•Œé¢ã€‚ ä¸ºä»€ä¹ˆï¼Ÿ å› ä¸ºå­˜å‚¨åº“çš„å®ç°ç»†èŠ‚ä¸GetPopularMoviesç”¨ä¾‹çš„åŠŸèƒ½æ— å…³ã€‚"
}, {
  "tag": "P",
  "text": "Take a look at GetPopularMovies code at line 5: does it matter if moviesRepository.getMovies() returns data from remote API or a local database? No, as long as the actual implementation implements the MoviesRepoitory interface â€” GetPopularMovies will work just fine!",
  "translation": "çœ‹ä¸€ä¸‹ç¬¬5è¡Œçš„GetPopularMoviesä»£ç ï¼šmovieRepository.getMoviesï¼ˆï¼‰ä»è¿œç¨‹APIæˆ–æœ¬åœ°æ•°æ®åº“è¿”å›æ•°æ®æ˜¯å¦é‡è¦ï¼Ÿ ä¸ï¼Œåªè¦å®é™…çš„å®ç°å®ç°äº†MoviesRepoitoryæ¥å£ï¼ŒGetPopularMovieså°±å¯ä»¥æ­£å¸¸å·¥ä½œï¼"
}, {
  "tag": "P",
  "text": "Before we continue with our tour, letâ€™s take a moment to talk about testing.",
  "translation": "åœ¨ç»§ç»­æ¸¸è§ˆä¹‹å‰ï¼Œè®©æˆ‘ä»¬èŠ±ä¸€ç‚¹æ—¶é—´è°ˆè®ºæµ‹è¯•ã€‚"
}, {
  "tag": "H2",
  "text": "Unit testing the use cases",
  "translation": "å•å…ƒæµ‹è¯•ç”¨ä¾‹"
}, {
  "tag": "P",
  "text": "The â€œignoranceâ€ of the domain layer allows us to test our use cases easily.Hereâ€™s GetPopularMovies unit test:",
  "translation": "åŸŸå±‚çš„â€œæ— çŸ¥â€ä½¿æˆ‘ä»¬èƒ½å¤Ÿè½»æ¾æµ‹è¯•ç”¨ä¾‹ã€‚è¿™é‡Œæ˜¯GetPopularMovieså•å…ƒæµ‹è¯•ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/e12b72dc118a3358f7fcb84eee322a1f/raw/f7411a181662791051a6e3faa2917c9c339966fc/movienight-testgetpopularmovies.kt",
  "code": "@Test\nfun testGetPopularMovies() {\n    val movieRepository = Mockito.mock(MoviesRepository::class.java)\n    Mockito.`when`(movieRepository.getMovies()).thenReturn(Observable.just(generateMovieEntityList()))\n    val getPopularMovies = GetPopularMovies(TestTransformer(), movieRepository)\n    getPopularMovies.observable().test()\n            .assertValue { results -> results.size == 5 }\n            .assertComplete()\n}"
}, {
  "tag": "P",
  "text": "Look at line 4: Since MoviesRepository is just an interface, I can easily mock its behavior using Mockito and return Observable with stub data when getMovies() is called.",
  "translation": "çœ‹ç¬¬4è¡Œï¼šç”±äºMoviesRepositoryåªæ˜¯ä¸€ä¸ªæ¥å£ï¼Œæˆ‘å¯ä»¥è½»æ¾åœ°ä½¿ç”¨Mockitoæ¨¡æ‹Ÿå…¶è¡Œä¸ºï¼Œå¹¶åœ¨è°ƒç”¨getMoviesï¼ˆï¼‰æ—¶è¿”å›å¸¦æœ‰å­˜æ ¹æ•°æ®çš„Observableã€‚"
}, {
  "tag": "P",
  "text": "Remember, use cases receives a Transformer when created? At line 5 Iâ€™m using TestTransformer to ensure synchronous execution of the use case so I can test more easily.",
  "translation": "è®°ä½ï¼Œç”¨ä¾‹åœ¨åˆ›å»ºæ—¶ä¼šæ”¶åˆ°ä¸€ä¸ªTransformerå—ï¼Ÿ åœ¨ç¬¬5è¡Œï¼Œæˆ‘æ­£åœ¨ä½¿ç”¨TestTransformeræ¥ç¡®ä¿ç”¨ä¾‹çš„åŒæ­¥æ‰§è¡Œï¼Œä»¥ä¾¿æˆ‘å¯ä»¥æ›´è½»æ¾åœ°è¿›è¡Œæµ‹è¯•ã€‚"
}, {
  "tag": "P",
  "text": "At Lines 7, 8 Iâ€™m completing the test by evaluating the data emitted by the use case and making sure itâ€™s the same data I mocked on line 4.",
  "translation": "åœ¨ç¬¬7è¡Œï¼Œç¬¬8è¡Œï¼Œæˆ‘å°†é€šè¿‡è¯„ä¼°ç”¨ä¾‹å‘å‡ºçš„æ•°æ®å¹¶ç¡®ä¿å®ƒä¸æˆ‘åœ¨ç¬¬4è¡Œä¸­æ¨¡æ‹Ÿçš„æ•°æ®ç›¸åŒæ¥å®Œæˆæµ‹è¯•ã€‚"
}, {
  "tag": "H2",
  "text": "Summarizing the domain layer",
  "translation": "æ€»ç»“é¢†åŸŸå±‚"
}, {
  "tag": "P",
  "text": "The domain layer sits at the very bottom of our code base. Here, we define our domain entities, interfaces and use cases for the upper layers to use. We keep things generic as much as we could to protect the core functionality from changes, leaving the hassle of dealing with implementations details to the upper layers.",
  "translation": "åŸŸå±‚ä½äºæˆ‘ä»¬ä»£ç åº“çš„æœ€åº•å±‚ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸Šå±‚è¦ä½¿ç”¨çš„åŸŸå®ä½“ï¼Œæ¥å£å’Œç”¨ä¾‹ã€‚ æˆ‘ä»¬å°½å¯èƒ½ä¿æŒé€šç”¨æ€§ï¼Œä»¥ä¿æŠ¤æ ¸å¿ƒåŠŸèƒ½ä¸å—æ›´æ”¹ï¼Œä»è€Œå°†å¤„ç†å®ç°ç»†èŠ‚çš„éº»çƒ¦ç•™ç»™äº†ä¸Šå±‚ã€‚"
}, {
  "tag": "P",
  "text": "Ok. letâ€™s move up to the data layer. ğŸ†™",
  "translation": "å¥½ã€‚ è®©æˆ‘ä»¬è¿›å…¥æ•°æ®å±‚ã€‚ ğŸ†™"
}, {
  "tag": "H1",
  "text": "The data layer",
  "translation": "æ•°æ®å±‚"
}, {
  "tag": "P",
  "text": "Just above the domain layer, we can find the data layer. Its purpose is to provide all the data the application needs to function.",
  "translation": "åœ¨åŸŸå±‚ä¹‹ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°æ•°æ®å±‚ã€‚ å…¶ç›®çš„æ˜¯æä¾›åº”ç”¨ç¨‹åºéœ€è¦è¿è¡Œçš„æ‰€æœ‰æ•°æ®ã€‚"
}, {
  "tag": "P",
  "text": "Weâ€™re no longer at the generic wonderland of the domain layer. Here, weâ€™ll find concrete implementations of the different data providers MovieNight is using. We can also see a new special type of classes in here â€” Mappers, but weâ€™ll get to them later.",
  "translation": "æˆ‘ä»¬ä¸å†æ˜¯åŸŸå±‚çš„é€šç”¨ä»™å¢ƒã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ‰¾åˆ°MovieNightä½¿ç”¨çš„ä¸åŒæ•°æ®æä¾›è€…çš„å…·ä½“å®ç°ã€‚ æˆ‘ä»¬è¿˜å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ä¸€ç§æ–°çš„ç‰¹æ®Šç±»å‹çš„ç±»-æ˜ å°„å™¨ï¼Œä½†ç¨åæˆ‘ä»¬å°†ä»‹ç»å®ƒä»¬ã€‚"
}, {
  "tag": "P",
  "text": "Keep in mind that the presentation layer is above the data layer, so the data providers have no knowledge regarding how and when they are invoked, which is a good thing.",
  "translation": "è¯·è®°ä½ï¼Œè¡¨ç¤ºå±‚åœ¨æ•°æ®å±‚ä¹‹ä¸Šï¼Œå› æ­¤æ•°æ®æä¾›è€…ä¸çŸ¥é“å¦‚ä½•ä»¥åŠä½•æ—¶è°ƒç”¨å®ƒä»¬ï¼Œè¿™æ˜¯ä¸€ä»¶å¥½äº‹ã€‚"
}, {
  "tag": "H2",
  "text": "Data providers implementation details",
  "translation": "æ•°æ®æä¾›è€…å®æ–½ç»†èŠ‚"
}, {
  "tag": "P",
  "text": "The implementation details of the data providers such as the caching mechanism, the database, and the networking manager are all here, so youâ€™ll find references to libraries such as Retrofit and Room. Of course, these libraries are wrapped by classes that correspond to the interfaces defined by the domain layer to hide their existence.",
  "translation": "æ•°æ®æä¾›ç¨‹åºçš„å®ç°è¯¦ç»†ä¿¡æ¯ï¼ˆä¾‹å¦‚ç¼“å­˜æœºåˆ¶ï¼Œæ•°æ®åº“å’Œç½‘ç»œç®¡ç†å™¨ï¼‰éƒ½åœ¨è¿™é‡Œï¼Œå› æ­¤æ‚¨å¯ä»¥æ‰¾åˆ°å¯¹è¯¸å¦‚Retrofitå’ŒRoomä¹‹ç±»çš„åº“çš„å¼•ç”¨ã€‚ å½“ç„¶ï¼Œè¿™äº›åº“ç”±ä¸é¢†åŸŸå±‚å®šä¹‰çš„æ¥å£ç›¸å¯¹åº”çš„ç±»åŒ…è£…ï¼Œä»¥éšè—å®ƒä»¬çš„å­˜åœ¨ã€‚"
}, {
  "tag": "P",
  "text": "Hereâ€™s one example: The MoviesRepository interface from the domain layer becomes MoviesRepositoryImpl (what an awful name!) in the data layer.",
  "translation": "è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼šåŸŸå±‚çš„MoviesRepositoryæ¥å£åœ¨æ•°æ®å±‚ä¸­å˜ä¸ºMoviesRepositoryImplï¼ˆçœŸæ˜¯ä¸ªç³Ÿç³•çš„åå­—ï¼ï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "Letâ€™s take a look at MoviesRepositoryImpl class:",
  "translation": "è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹MoviesRepositoryImplç±»ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/df564226610ee1939b3f83687efd4c25/raw/457a435557272feec1cab6c591d9bc3e71bd50f5/movienight-MoviesRepositoryImpl.kt",
  "code": "class MoviesRepositoryImpl(api: Api,\n                           private val cache: MoviesCache,\n                           movieDataMapper: Mapper<MovieData, MovieEntity>,\n                           detailedDataMapper: Mapper<DetailsData, MovieEntity>) : MoviesRepository {\n\n    private val memoryDataStore: MoviesDataStore\n    private val remoteDataStore: MoviesDataStore\n\n    init {\n        memoryDataStore = CachedMoviesDataStore(cache)\n        remoteDataStore = RemoteMoviesDataStore(api, movieDataMapper, detailedDataMapper)\n    }\n\n    override fun getMovies(): Observable<List<MovieEntity>> {\n        return if (!cache.isEmpty()) {\n            return memoryDataStore.getMovies()\n        } else {\n            remoteDataStore.getMovies().doOnNext { cache.saveAll(it) }\n        }\n    }\n\n    override fun search(query: String): Observable<List<MovieEntity>> {\n        return remoteDataStore.search(query)\n    }\n\n    override fun getMovie(movieId: Int): Observable<Optional<MovieEntity>> {\n        return remoteDataStore.getMovieById(movieId)\n    }\n}"
}, {
  "tag": "P",
  "text": "Things that worth mentioning here are:",
  "translation": "è¿™é‡Œå€¼å¾—ä¸€æçš„æ˜¯ï¼š"
}, {
  "tag": "UL",
  "texts": ["MoviesRepositoryImpl implements the MoviesRepository interface.So it can be used by the domain use cases.", "This class acts as a factory that can â€œjuggleâ€ between the remote data store and the local data store. getMovies() implementation checks for the presence of cached data before accessing the API. Other methods such as search() invoke the API directly.", "The data sources implementation is abstractedEven though they belong on the same layer with MoviesRepositoryImpl, and technically we wonâ€™t break the dependencies rule by revealing their implementation, the knowledge of any details regarding the data sources is irrelevant for the functionality of MoviesRepositoryImpl, so we abstract them behind MoviesDataStore interfaces. (and of course, MoviesDataStore is defined inside the domain layer)", "Mappers are being usedI mentioned the mappers at the beginning of the section, and now itâ€™s time to talk about them."],
  "translations": ["MoviesRepositoryImplå®ç°äº†MoviesRepositoryæ¥å£ï¼Œå› æ­¤å¯ä»¥åœ¨åŸŸç”¨ä¾‹ä¸­ä½¿ç”¨ã€‚", "æ­¤ç±»å……å½“å·¥å‚ï¼Œå¯ä»¥åœ¨è¿œç¨‹æ•°æ®å­˜å‚¨å’Œæœ¬åœ°æ•°æ®å­˜å‚¨ä¹‹é—´â€œå˜æˆæ³•â€ã€‚ getMoviesï¼ˆï¼‰å®ç°åœ¨è®¿é—®APIä¹‹å‰æ£€æŸ¥ç¼“å­˜æ•°æ®çš„å­˜åœ¨ã€‚ å…¶ä»–æ–¹æ³•ï¼ˆä¾‹å¦‚searchï¼ˆï¼‰ï¼‰ç›´æ¥è°ƒç”¨APIã€‚", "æ•°æ®æºå®ç°æ˜¯æŠ½è±¡çš„ï¼Œå³ä½¿å®ƒä»¬ä¸MoviesRepositoryImplå±äºåŒä¸€å±‚ï¼Œä»æŠ€æœ¯ä¸Šè®²ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šé€šè¿‡æ­ç¤ºå®ƒä»¬çš„å®ç°æ¥æ‰“ç ´ä¾èµ–å…³ç³»è§„åˆ™ï¼Œæœ‰å…³æ•°æ®æºçš„ä»»ä½•è¯¦ç»†ä¿¡æ¯çš„çŸ¥è¯†ä¸MoviesRepositoryImplçš„åŠŸèƒ½æ— å…³ã€‚ åœ¨MoviesDataStoreæ¥å£åé¢æŠ½è±¡å®ƒä»¬ã€‚ ï¼ˆå½“ç„¶ï¼ŒMoviesDataStoreæ˜¯åœ¨åŸŸå±‚å†…éƒ¨å®šä¹‰çš„ï¼‰", "æˆ‘æ­£åœ¨æœ¬èŠ‚çš„å¼€å¤´æåˆ°æ˜ å°„å™¨ï¼Œç°åœ¨æ˜¯æ—¶å€™è®¨è®ºå®ƒä»¬äº†ã€‚"]
}, {
  "tag": "H2",
  "text": "Mappers",
  "translation": "æ˜ å°„å™¨"
}, {
  "tag": "P",
  "text": "Mappers, as their name suggests, are classes who â€œknowsâ€ how to map class A to class B. All the mappers in MovieNight extends the Mapper abstract class:",
  "translation": "é¡¾åæ€ä¹‰ï¼Œæ˜ å°„å™¨æ˜¯â€œçŸ¥é“â€å¦‚ä½•å°†ç±»Aæ˜ å°„åˆ°ç±»Bçš„ç±»ã€‚MovieNightä¸­çš„æ‰€æœ‰æ˜ å°„å™¨éƒ½æ‰©å±•äº†MapperæŠ½è±¡ç±»ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/fcf47f7c6b509169b19ff038feb6d4d4/raw/f0057a4661c0f53ebb19076a20bda9ea4a1e50d5/movienight-mapper.kt",
  "code": "abstract class Mapper<in E, T> {\n    \n    abstract fun mapFrom(from: E): T\n\n    fun mapOptional(from: Optional<E>): Optional<T> {\n        from.value?.let {\n            return Optional.of(mapFrom(it))\n        } ?: return Optional.empty()\n    }\n\n    fun observable(from: E): Observable<T> {\n        return Observable.fromCallable { mapFrom(from) }\n    }\n\n    fun observable(from: List<E>): Observable<List<T>> {\n        return Observable.fromCallable { from.map { mapFrom(it) } }\n    }\n}"
}, {
  "tag": "P",
  "text": "Thereâ€™s a whole bunch of convenience methods in here, but the core functionality is pretty straightforward (line 3): Insert class A from one side, get class B from the other side.",
  "translation": "è¿™é‡Œæœ‰å¾ˆå¤šä¾¿åˆ©æ–¹æ³•ï¼Œä½†æ˜¯æ ¸å¿ƒåŠŸèƒ½éå¸¸ç®€å•ï¼ˆç¬¬3è¡Œï¼‰ï¼šä»ä¸€ä¾§æ’å…¥Aç±»ï¼Œä»å¦ä¸€ä¾§æ’å…¥Bç±»ã€‚"
}, {
  "tag": "H2",
  "text": "Why do we need mappers?",
  "translation": "ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦æ˜ å°„å™¨ï¼Ÿ"
}, {
  "tag": "P",
  "text": "The domain entities, which are the base data structure for our application are defined in the domain layer. They shouldnâ€™t have any knowledge of the â€œoutside worldâ€ or their â€œpurityâ€ would be compromised (I hope that you understand why this is a bad thing by now).",
  "translation": "åŸŸå®ä½“æ˜¯æˆ‘ä»¬åº”ç”¨ç¨‹åºçš„åŸºæœ¬æ•°æ®ç»“æ„ï¼Œåœ¨åŸŸå±‚ä¸­å®šä¹‰ã€‚ ä»–ä»¬ä¸åº”è¯¥å¯¹â€œå¤–éƒ¨ä¸–ç•Œâ€æœ‰ä»»ä½•äº†è§£ï¼Œå¦åˆ™ä»–ä»¬çš„â€œçº¯åº¦â€ä¼šå—åˆ°æŸå®³ï¼ˆæˆ‘å¸Œæœ›æ‚¨ç°åœ¨æ˜ç™½ä¸ºä»€ä¹ˆè¿™æ˜¯ä¸€ä»¶åäº‹ï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "The problem is that the data layer contains specific implementations and specific implementation tends to have specific needs. Retrofit is an obvious example: to allow Retrofit to parse network responses we often use libraries such as GSON. To make the parsing work GSON have a set of annotations we can use to instruct the parser. No annotations mean no parsing but we canâ€™t possibly annotate the domain entities with GSON annotations. The domain layer has no idea what GSON is.",
  "translation": "é—®é¢˜åœ¨äºæ•°æ®å±‚åŒ…å«ç‰¹å®šçš„å®ç°ï¼Œå¹¶ä¸”ç‰¹å®šçš„å®ç°å¾€å¾€å…·æœ‰ç‰¹å®šçš„éœ€æ±‚ã€‚ æ”¹é€ å°±æ˜¯ä¸€ä¸ªæ˜æ˜¾çš„ä¾‹å­ï¼šä¸ºäº†ä½¿æ”¹é€ èƒ½å¤Ÿè§£æç½‘ç»œå“åº”ï¼Œæˆ‘ä»¬ç»å¸¸ä½¿ç”¨è¯¸å¦‚GSONä¹‹ç±»çš„åº“ã€‚ ä¸ºäº†ä½¿è§£æå·¥ä½œæ›´åŠ æœ‰æ¡ç†ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨GSONæ³¨é‡Šæ¥æŒ‡ç¤ºè§£æå™¨ã€‚ æ²¡æœ‰æ³¨é‡Šæ„å‘³ç€æ²¡æœ‰è§£æï¼Œä½†æˆ‘ä»¬å¯èƒ½æ— æ³•ä½¿ç”¨GSONæ³¨é‡Šæ¥æ³¨é‡ŠåŸŸå®ä½“ã€‚ åŸŸå±‚ä¸çŸ¥é“ä»€ä¹ˆæ˜¯GSONã€‚"
}, {
  "tag": "P",
  "text": "What can we do? We can create a new set of entities, entities that can be annotated and work with Retrofit. These entities will live inside the data layer, far away from the domain entities. One such class is MovieData:",
  "translation": "æˆ‘ä»¬å¯ä»¥åšä»€ä¹ˆï¼Ÿ æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ç»„æ–°çš„å®ä½“ï¼Œè¿™äº›å®ä½“å¯ä»¥æ·»åŠ æ³¨é‡Šå¹¶å¯ä»¥ä¸Retrofitä¸€èµ·ä½¿ç”¨ã€‚ è¿™äº›å®ä½“å°†ä½äºæ•°æ®å±‚å†…éƒ¨ï¼Œä¸åŸŸå®ä½“ç›¸è·å¾ˆè¿œã€‚ è¿™æ ·çš„ç±»å°±æ˜¯MovieDataï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/3c450fa2ec1ad2fc12c173c043114d10/raw/c16ffb8c9a857af87a525705569dcd1233378d90/movienight-moviedata.kt",
  "code": "@Entity(tableName = \"movies\")\ndata class MovieData(\n\n        @SerializedName(\"id\")\n        @PrimaryKey\n        var id: Int = -1,\n\n        @SerializedName(\"vote_count\")\n        var voteCount: Int = 0,\n\n        @SerializedName(\"vote_average\")\n        var voteAverage: Double = 0.0\n        \n        // ...\n}"
}, {
  "tag": "P",
  "text": "Itâ€™s hard to tell by the gist but MovieData is very similar to the domain entity, MovieEntity, the only difference between them is that MovieData contains specific implementation code (Retrofit and Room libraries annotations).",
  "translation": "è¦ç‚¹å¾ˆéš¾è¯´ï¼Œä½†æ˜¯MovieDataä¸åŸŸå®ä½“MovieEntityéå¸¸ç›¸ä¼¼ï¼Œå®ƒä»¬ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«æ˜¯MovieDataåŒ…å«ç‰¹å®šçš„å®ç°ä»£ç ï¼ˆRetrofitå’ŒRoomåº“æ³¨é‡Šï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "So if Retrofit response holds a list of movies, they are now represented by an array of MovieData objects instead of MovieEntity objects. Problem solved? Nope. ğŸ˜Ÿ",
  "translation": "å› æ­¤ï¼Œå¦‚æœRetrofitå“åº”åŒ…å«ç”µå½±åˆ—è¡¨ï¼Œåˆ™å®ƒä»¬ç°åœ¨ç”±MovieDataå¯¹è±¡æ•°ç»„è€Œä¸æ˜¯MovieEntityå¯¹è±¡è¡¨ç¤ºã€‚ é—®é¢˜è§£å†³äº†ï¼Ÿ ä¸ã€‚ ğŸ˜Ÿ"
}, {
  "tag": "P",
  "text": "Thereâ€™s another problem: the use cases (domain layer residents) have no idea what MovieData is, they only familiar with MovieEntity! What can we do? We can map MovieData to MovieEntity everytime we cross the boundary between the data layer to the domain layer â€”> Enter mappers.",
  "translation": "è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼šç”¨ä¾‹ï¼ˆåŸŸå±‚å±…æ°‘ï¼‰ä¸çŸ¥é“MovieDataæ˜¯ä»€ä¹ˆï¼Œåªç†Ÿæ‚‰MovieEntityï¼ æˆ‘ä»¬å¯ä»¥åšä»€ä¹ˆï¼Ÿ æ¯å½“æˆ‘ä»¬è·¨è¶Šæ•°æ®å±‚ä¸åŸŸå±‚ä¹‹é—´çš„è¾¹ç•Œæ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†MovieDataæ˜ å°„åˆ°MovieEntity ï¼>è¾“å…¥æ˜ å°„å™¨ã€‚"
}, {
  "tag": "H2",
  "text": "Testing the data layer",
  "translation": "æµ‹è¯•æ•°æ®å±‚"
}, {
  "tag": "P",
  "text": "Most of the tests here are unit tests (Room depends on the Android framework, so I test it using instrumentation), and since we abstract most of the implementations even between residents of the data layer, itâ€™s pretty easy to test the core functionality. Letâ€™s take a look at a small part of MoviesRepositoryImpl tests suit:",
  "translation": "è¿™é‡Œçš„å¤§å¤šæ•°æµ‹è¯•éƒ½æ˜¯å•å…ƒæµ‹è¯•ï¼ˆRoomå–å†³äºAndroidæ¡†æ¶ï¼Œå› æ­¤æˆ‘ä½¿ç”¨å·¥å…·å¯¹å…¶è¿›è¡Œæµ‹è¯•ï¼‰ï¼Œå¹¶ä¸”ç”±äºæˆ‘ä»¬å¯¹å¤§å¤šæ•°å®ç°è¿›è¡Œäº†æŠ½è±¡ï¼Œå³ä½¿æ˜¯åœ¨æ•°æ®å±‚çš„å±…æ°‘ä¹‹é—´ï¼Œå› æ­¤æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½ä¹Ÿéå¸¸å®¹æ˜“ã€‚ è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹MoviesRepositoryImplæµ‹è¯•å¥—è£…çš„ä¸€å°éƒ¨åˆ†ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/82cbac0c67394ae72f0ae9ec02086964/raw/601668f4941c78ae013183b5ef7b23d3f3fccb68/movienight-moviesRepositoryImplTests.kt",
  "code": "@Before\nfun before() {\n    api = mock(Api::class.java)\n    movieCache = TestMoviesCache()\n    movieRepository = MoviesRepositoryImpl(api, movieCache, movieDataMapper, detailsDataMapper)\n}\n\n@Test\nfun testWhenCacheIsNotEmptyGetMoviesReturnsCachedMovies() {\n\n    movieCache.saveAll(generateMovieEntityList())\n    movieRepository.getMovies().test()\n            .assertComplete()\n            .assertValue { movies -> movies.size == 5 }\n\n    verifyZeroInteractions(api)\n}\n\n@Test\nfun testWhenCacheIsEmptyGetMoviesReturnsMoviesFromApi() {\n   val movieListResult = MovieListResult()\n   movieListResult.movies = TestsUtils.generateMovieDataList()\n   `when`(api.getPopularMovies()).thenReturn(Observable.just(movieListResult))\n    movieRepository.getMovies().test()\n            .assertComplete()\n            .assertValue { movies -> movies.size == 5 }\n}"
}, {
  "tag": "P",
  "text": "As we can see, all the data sources used by MoviesRepositoryImpl are abstracted by interfaces, so we easily mock them using Mockito or create a simple implementations for testing purposes to test the caching mechanism without too much of a hassle.",
  "translation": "å¦‚æˆ‘ä»¬æ‰€è§ï¼ŒMoviesRepositoryImplä½¿ç”¨çš„æ‰€æœ‰æ•°æ®æºéƒ½æ˜¯é€šè¿‡æ¥å£æŠ½è±¡çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°ä½¿ç”¨Mockitoå¯¹å…¶è¿›è¡Œæ¨¡æ‹Ÿï¼Œä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªç®€å•çš„å®ç°ç”¨äºæµ‹è¯•ç›®çš„ï¼Œä»¥æµ‹è¯•ç¼“å­˜æœºåˆ¶è€Œä¸ä¼šäº§ç”Ÿå¤ªå¤šéº»çƒ¦ã€‚"
}, {
  "tag": "H2",
  "text": "Summarizing the data layer",
  "translation": "æ€»ç»“æ•°æ®å±‚"
}, {
  "tag": "P",
  "text": "The data layer sits between the domain layer and the presentation layer. Here, we define our data providers implementation details. We still try to abstract the different components and hide their implementation from one to another to support changes and easily test the core functionality.",
  "translation": "æ•°æ®å±‚ä½äºåŸŸå±‚å’Œè¡¨ç¤ºå±‚ä¹‹é—´ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å®šä¹‰äº†æ•°æ®æä¾›ç¨‹åºçš„å®ç°ç»†èŠ‚ã€‚ æˆ‘ä»¬ä»ç„¶å°è¯•æŠ½è±¡ä¸åŒçš„ç»„ä»¶ï¼Œå¹¶å°†å®ƒä»¬çš„å®ç°å½¼æ­¤éšè—èµ·æ¥ï¼Œä»¥æ”¯æŒæ›´æ”¹å¹¶è½»æ¾æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½ã€‚"
}, {
  "tag": "P",
  "text": "Next up â€” the presentation layer.",
  "translation": "æ¥ä¸‹æ¥-è¡¨ç¤ºå±‚ã€‚"
}, {
  "tag": "H1",
  "text": "The presentation layer",
  "translation": "è¡¨ç¤ºå±‚"
}, {
  "tag": "P",
  "text": "Weâ€™ve made it to the top! The presentation layer connects all the different pieces into a single, functioning unit that is the application. Here, weâ€™ll find Activities and Fragments, the UI and presenters under (sort of) an MVP architecture, mappers, and dependency injection framework thatâ€™s wires everything across the application.",
  "translation": "æˆ‘ä»¬å·²ç»ç™»é¡¶ï¼ è¡¨ç¤ºå±‚å°†æ‰€æœ‰ä¸åŒéƒ¨åˆ†è¿æ¥åˆ°ä¸€ä¸ªå•ç‹¬çš„åŠŸèƒ½å•å…ƒä¸­ï¼Œå³åº”ç”¨ç¨‹åºã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†åœ¨MVPæ¶æ„ï¼Œæ˜ å°„å™¨å’Œä¾èµ–é¡¹æ³¨å…¥æ¡†æ¶ï¼ˆæŸç§ç¨‹åº¦ä¸Šï¼‰ä¸‹æ‰¾åˆ°æ´»åŠ¨å’Œç‰‡æ®µï¼ŒUIå’Œæ¼”ç¤ºè€…ï¼Œè¿™äº›æ¡†æ¶å°†æ•´ä¸ªåº”ç”¨ç¨‹åºå…³è”åœ¨ä¸€èµ·ã€‚"
}, {
  "tag": "H1",
  "text": "Presentation layer architecture",
  "translation": "è¡¨ç¤ºå±‚æ¶æ„"
}, {
  "tag": "P",
  "text": "Notice the big headline? Yeah, thatâ€™s because this section can easily be its own blog post, but Iâ€™m assuming (hoping?) that youâ€™ve got MovieNight source code in front of you. Iâ€™ll try to keep this part short and to the point and let you figure out all the different details by yourself. *fist bump* ğŸ¤œ ğŸ¤›",
  "translation": "æ³¨æ„å¤§æ ‡é¢˜å—ï¼Ÿ æ˜¯çš„ï¼Œå› ä¸ºè¿™éƒ¨åˆ†å¾ˆå®¹æ˜“æˆä¸ºå…¶è‡ªå·±çš„åšå®¢æ–‡ç« ï¼Œä½†æ˜¯æˆ‘å‡è®¾ï¼ˆå¸Œæœ›å—ï¼Ÿï¼‰æ‚¨å·²ç»æŒæ¡äº†MovieNightæºä»£ç ã€‚ æˆ‘ä¼šå°½é‡ç²¾ç®€è¿™ä¸€éƒ¨åˆ†ï¼Œè®©æ‚¨è‡ªå·±æ‰¾å‡ºæ‰€æœ‰ä¸åŒçš„ç»†èŠ‚ã€‚ *æ‹³å¤´**"
}, {
  "tag": "P",
  "text": "The presentation layer is organized by something that resembles MVP architecture. Itâ€™s actually a hybrid between several architecture ideas Iâ€™m currently experimenting with ğŸ‘½.",
  "translation": "è¡¨ç¤ºå±‚æ˜¯ç”±ç±»ä¼¼äºMVPæ¶æ„çš„ä¸œè¥¿ç»„ç»‡çš„ã€‚ å®é™…ä¸Šï¼Œè¿™æ˜¯æˆ‘ç›®å‰æ­£åœ¨å°è¯•ğŸ‘½çš„å‡ ç§æ¶æ„æ€æƒ³ä¹‹é—´çš„æ··åˆä½“ã€‚"
}, {
  "tag": "H2",
  "text": "Views and ViewStates",
  "translation": "è§†å›¾å’Œè§†å›¾çŠ¶æ€"
}, {
  "tag": "P",
  "text": "Unlike in MVP, the views arenâ€™t implementing an interface thatâ€™s get invoked by the presenter. Instead, the view is observing changes in a ViewState objects. These ViewStates are delivered by LiveData objects. The LiveData objects being updated, and are part of, a presenter. Itâ€™s worth mentioning that a presenter can hold more than one LiveData objects, and the view will register to all of them.",
  "translation": "ä¸MVPä¸­çš„è§†å›¾ä¸åŒï¼Œè§†å›¾å¹¶æ²¡æœ‰å®ç°æ¼”ç¤ºè€…è°ƒç”¨çš„æ¥å£ã€‚ ç›¸åï¼Œè¯¥è§†å›¾æ­£åœ¨è§‚å¯ŸViewStateå¯¹è±¡ä¸­çš„æ›´æ”¹ã€‚ è¿™äº›ViewStateç”±LiveDataå¯¹è±¡ä¼ é€’ã€‚ LiveDataå¯¹è±¡æ­£åœ¨æ›´æ–°ï¼Œå¹¶ä¸”æ˜¯æ¼”ç¤ºè€…çš„ä¸€éƒ¨åˆ†ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæ¼”ç¤ºè€…å¯ä»¥å®¹çº³å¤šä¸ªLiveDataå¯¹è±¡ï¼Œå¹¶ä¸”è§†å›¾å°†æ³¨å†Œåˆ°æ‰€æœ‰è¿™äº›å¯¹è±¡ã€‚"
}, {
  "tag": "P",
  "text": "A ViewState is just a data container, holding all the information the view needs to render himself. Letâ€™s look at a simple example; This is the ViewState for the popular movies screen:",
  "translation": "ViewStateåªæ˜¯ä¸€ä¸ªæ•°æ®å®¹å™¨ï¼Œå…¶ä¸­åŒ…å«è§†å›¾éœ€è¦å‘ˆç°çš„æ‰€æœ‰ä¿¡æ¯ã€‚ è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼› è¿™æ˜¯æµè¡Œç”µå½±å±å¹•çš„ViewStateï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/af9aba06c74869c1382d0bbc9529d924/raw/ff720c6b4698e8c6170ec1788412467e40c17df6/movienight-popularmovies-viewstate.kt",
  "code": "data class PopularMoviesViewState(\n        var showLoading: Boolean = true,\n        var movies: List<Movie>? = null\n)"
}, {
  "tag": "P",
  "text": "Simple isnâ€™t it? by â€œreadingâ€ the ViewState the view knows if the loading indicator should be displayed or what Movie objects to show. (Yes, Thereâ€™s a new Movie object in here).",
  "translation": "æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼Ÿ é€šè¿‡â€œè¯»å–â€ ViewStateï¼Œè§†å›¾å¯ä»¥çŸ¥é“æ˜¯å¦åº”è¯¥æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨æˆ–è¦æ˜¾ç¤ºå“ªäº›Movieå¯¹è±¡ã€‚ ï¼ˆæ˜¯çš„ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæ–°çš„ç”µå½±å¯¹è±¡ï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "Hereâ€™s how the view, PopularMoviesFragment, handles the ViewState:",
  "translation": "è¿™æ˜¯ViewPopularMoviesFragmentå¤„ç†ViewStateçš„æ–¹æ³•ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/4c35a58e2504e0fb8f345c7b6505f60a/raw/9cee45ba7d9f1b0b6e10736fb3001978e5d37551/movienight-handling-ViewState.kt",
  "code": "private lateinit var progressBar: ProgressBar\nprivate lateinit var popularMoviesAdapter: PopularMoviesAdapter\n\n// ...\n\nprivate fun handleViewState(state: PopularMoviesViewState) {\n        progressBar.visibility = if (state.showLoading) View.VISIBLE else View.GONE\n        state.movies?.let { popularMoviesAdapter.addMovies(it) }\n}"
}, {
  "tag": "P",
  "text": "And as I already mentioned, the ViewState object is being updated by the presenter.",
  "translation": "æ­£å¦‚æˆ‘å·²ç»æåˆ°çš„ï¼Œæ¼”ç¤ºè€…æ­£åœ¨æ›´æ–°ViewStateå¯¹è±¡ã€‚"
}, {
  "tag": "H2",
  "text": "The presenters",
  "translation": "ä¸»æŒäºº"
}, {
  "tag": "P",
  "text": "The presenters in MovieNight are Androidâ€™s ViewModel objects. I know, itâ€™s a bit confusing. If someone is keeping score add +1 to Google under the â€œannoying naming conventionsâ€ category. But enough ranting, letâ€™s continue. Itâ€™s worth noting that the presenters model are actually the domain layer use cases.",
  "translation": "MovieNightä¸­çš„æ¼”ç¤ºè€…æ˜¯Androidçš„ViewModelå¯¹è±¡ã€‚ æˆ‘çŸ¥é“ï¼Œè¿™æœ‰ç‚¹ä»¤äººå›°æƒ‘ã€‚ å¦‚æœæœ‰äººä¿æŒå¾—åˆ†ï¼Œè¯·åœ¨â€œè®¨åŒçš„å‘½åçº¦å®šâ€ç±»åˆ«ä¸‹å‘Google +1ã€‚ ä½†æ˜¯è¶³å¤Ÿçš„å’†å“®ï¼Œè®©æˆ‘ä»¬ç»§ç»­ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸»æŒäººæ¨¡å‹å®é™…ä¸Šæ˜¯åŸŸå±‚ç”¨ä¾‹ã€‚"
}, {
  "tag": "H2",
  "text": "Why using ViewModels?",
  "translation": "ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ViewModelsï¼Ÿ"
}, {
  "tag": "P",
  "text": "Some will correctly point out that the presenters should stay away from the Android framework. By using ViewModels, Iâ€™m â€œtellingâ€ the presenters about Android lifecycle events, and this is not ideal. So why did I choose to do this?",
  "translation": "æœ‰äº›äººä¼šæ­£ç¡®æŒ‡å‡ºï¼Œä¸»æŒäººåº”è¯¥è¿œç¦»Androidæ¡†æ¶ã€‚ é€šè¿‡ä½¿ç”¨ViewModelsï¼Œæˆ‘å¯ä»¥â€œå‘Šè¯‰â€æ¼”ç¤ºè€…æœ‰å…³Androidç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„ä¿¡æ¯ï¼Œä½†è¿™å¹¶ä¸ç†æƒ³ã€‚ é‚£æˆ‘ä¸ºä»€ä¹ˆé€‰æ‹©è¿™æ ·åšå‘¢ï¼Ÿ"
}, {
  "tag": "P",
  "text": "Because everything is a trade-off. I choose to sacrifice a certain degree of abstraction and gain seamless, â€œbattle testedâ€, lifecycle events handling. It is simple as that.",
  "translation": "å› ä¸ºä¸€åˆ‡éƒ½æ˜¯æƒè¡¡çš„ã€‚ æˆ‘é€‰æ‹©ç‰ºç‰²æŸç§ç¨‹åº¦çš„æŠ½è±¡å¹¶è·å¾—æ— ç¼çš„ï¼Œç»è¿‡â€œæˆ˜æ–—æµ‹è¯•â€çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¤„ç†ã€‚ å°±è¿™ä¹ˆç®€å•ã€‚"
}, {
  "tag": "P",
  "text": "Letâ€™s take a look at presenter example. Hereâ€™s PopularMoviesViewModel:",
  "translation": "è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æ¼”ç¤ºè€…ç¤ºä¾‹ã€‚ è¿™æ˜¯PopularMoviesViewModelï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/9cc6cd790bd649ffde33390c233824ee/raw/347f250f6850a991bc91f0f318d8a9f4f4741a91/movienight-PopularMoviesViewModel.kt",
  "code": "class PopularMoviesViewModel(private val getPopularMovies: GetPopularMovies,\n                             private val movieEntityMovieMapper: Mapper<MovieEntity, Movie>):\n        BaseViewModel() {\n\n    var viewState: MutableLiveData<PopularMoviesViewState> = MutableLiveData()\n    var errorState: SingleLiveEvent<Throwable?> = SingleLiveEvent()\n\n    init {\n        viewState.value = PopularMoviesViewState()\n    }\n\n    fun getPopularMovies() {\n        addDisposable(getPopularMovies.observable()\n                .flatMap { movieEntityMovieMapper.observable(it) }\n                .subscribe({ movies ->\n                    viewState.value?.let {\n                        val newState = this.viewState.value?.copy(showLoading = false, movies = movies)\n                        this.viewState.value = newState\n                        this.errorState.value = null\n                    }\n                }, {\n                    viewState.value = viewState.value?.copy(showLoading = false)\n                    errorState.value = it\n                }))\n    }\n}"
}, {
  "tag": "P",
  "text": "Many interesting stuff are going on in here, letâ€™s tackle them â€œin order of appearanceâ€:",
  "translation": "è¿™é‡Œå‘ç”Ÿäº†è®¸å¤šæœ‰è¶£çš„äº‹æƒ…ï¼Œè®©æˆ‘ä»¬â€œæŒ‰å‡ºç°é¡ºåºâ€è§£å†³å®ƒä»¬ï¼š"
}, {
  "tag": "P",
  "text": "Lines 5, 6: These are the LiveData objects the view will observe. One of them is carrying the ViewState object, the other is carrying an optional Throwable. Notice that errorState is a special type of LiveData called SingleLiveEvent, itâ€™s purpose is to send update events only one time, this is really useful during configuration change.",
  "translation": "ç¬¬5ã€6è¡Œï¼šè¿™äº›æ˜¯è§†å›¾å°†è§‚å¯Ÿçš„LiveDataå¯¹è±¡ã€‚ å…¶ä¸­ä¸€ä¸ªå¸¦æœ‰ViewStateå¯¹è±¡ï¼Œå¦ä¸€ä¸ªå¸¦æœ‰å¯é€‰çš„Throwableã€‚ è¯·æ³¨æ„ï¼ŒerrorStateæ˜¯LiveDataçš„ä¸€ç§ç‰¹æ®Šç±»å‹ï¼Œç§°ä¸ºSingleLiveEventï¼Œå…¶ç›®çš„æ˜¯ä»…å‘é€ä¸€æ¬¡æ›´æ–°äº‹ä»¶ï¼Œè¿™åœ¨é…ç½®æ›´æ”¹æœŸé—´éå¸¸æœ‰ç”¨ã€‚"
}, {
  "tag": "P",
  "text": "Line 13: addDisposable() is BaseViewModel method that registers a RxJava subscription to CompositeSubscription. The BaseViewModel calls compositeDisposable.clear() when the ViewModel onCleared() is called.",
  "translation": "ç¬¬13è¡Œï¼šaddDisposableï¼ˆï¼‰æ˜¯BaseViewModelæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†RxJavaè®¢é˜…æ³¨å†Œåˆ°CompositeSubscriptionã€‚ è°ƒç”¨ViewModel onClearedï¼ˆï¼‰æ—¶ï¼ŒBaseViewModelè°ƒç”¨CompositeDisposable.clearï¼ˆï¼‰ã€‚"
}, {
  "tag": "P",
  "text": "Lines 13â€“19: Here we can see how the presenter is using the use case as a model:",
  "translation": "ç¬¬13-19è¡Œï¼šåœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¼”ç¤ºè€…å¦‚ä½•å°†ç”¨ä¾‹ç”¨ä½œæ¨¡å‹ï¼š"
}, {
  "tag": "UL",
  "texts": ["Line 13: The presenter subscribes to the use case observable.", "Line 14: Using a mapper the domain layer entities are mapped into presentation layer entities.", "Lines 16â€“19: The LiveData value is updated with a new ViewState object. Notice the usage of the copy() method that copies the object parameters into a brand new object, allowing us to keep the ViewStates immutable. We get the copy() method â€œfor freeâ€ by using Kotlin data class for the ViewState."],
  "translations": ["ç¬¬13è¡Œï¼šæ¼”ç¤ºè€…è®¢é˜…äº†å¯è§‚å¯Ÿçš„ç”¨ä¾‹ã€‚", "ç¬¬14è¡Œï¼šä½¿ç”¨æ˜ å°„å™¨å°†åŸŸå±‚å®ä½“æ˜ å°„åˆ°è¡¨ç¤ºå±‚å®ä½“ã€‚", "ç¬¬16-19è¡Œï¼šä½¿ç”¨æ–°çš„ViewStateå¯¹è±¡æ›´æ–°LiveDataå€¼ã€‚ è¯·æ³¨æ„copyï¼ˆï¼‰æ–¹æ³•çš„ç”¨æ³•ï¼Œè¯¥æ–¹æ³•å°†å¯¹è±¡å‚æ•°å¤åˆ¶åˆ°å…¨æ–°çš„å¯¹è±¡ä¸­ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿä¿æŒViewStatesä¸å¯å˜ã€‚ é€šè¿‡å°†Kotlinæ•°æ®ç±»ç”¨äºViewStateï¼Œæˆ‘ä»¬å¯ä»¥â€œå…è´¹â€è·å¾—copyï¼ˆï¼‰æ–¹æ³•ã€‚"]
}, {
  "tag": "P",
  "text": "And this wraps up the presenter section. Itâ€™s time to talk about another part of the presentation layer â€” the dependencies injection.",
  "translation": "è¿™å°±å®Œæˆäº†æ¼”è®²è€…éƒ¨åˆ†ã€‚ ç°åœ¨è¯¥è®¨è®ºè¡¨ç¤ºå±‚çš„å¦ä¸€éƒ¨åˆ†-ä¾èµ–é¡¹æ³¨å…¥ã€‚"
}, {
  "tag": "H2",
  "text": "Dependency injection",
  "translation": "ä¾èµ–æ³¨å…¥"
}, {
  "tag": "P",
  "text": "As I previously mentioned, the dependency injection (Iâ€™ll refer to it as DI from now on) wires everything across the application. The DI is responsible for providing concrete implementations in a code base ruled by abstractions.",
  "translation": "å¦‚å‰æ‰€è¿°ï¼Œä¾èµ–é¡¹æ³¨å…¥ï¼ˆä»ç°åœ¨å¼€å§‹å°†å…¶ç§°ä¸ºDIï¼‰å°†æ•´ä¸ªåº”ç”¨ç¨‹åºè¿æ¥èµ·æ¥ã€‚ DIè´Ÿè´£åœ¨ç”±æŠ½è±¡æ§åˆ¶çš„ä»£ç åº“ä¸­æä¾›å…·ä½“çš„å®ç°ã€‚"
}, {
  "tag": "P",
  "text": "MovieNight DI is based on the Dagger2 library. If youâ€™re familiar with Dagger2, itâ€™s worth mentioning that Iâ€™m using SubComponents with custom Scopes to control the scoping of different injections. This allows screen-specific injected objects such as use cases and ViewModel factories to be released from memory when they are no longer needed.",
  "translation": "MovieNight DIåŸºäºDagger2åº“ã€‚ å¦‚æœæ‚¨ç†Ÿæ‚‰Dagger2ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘æ­£åœ¨ä½¿ç”¨å…·æœ‰è‡ªå®šä¹‰èŒƒå›´çš„å­ç»„ä»¶æ¥æ§åˆ¶ä¸åŒè¿›æ ·çš„èŒƒå›´ã€‚ è¿™æ ·å°±å¯ä»¥åœ¨ä¸å†éœ€è¦ç‰¹å®šäºå±å¹•çš„æ³¨å…¥å¯¹è±¡ï¼ˆä¾‹å¦‚ç”¨ä¾‹å’ŒViewModelå·¥å‚ï¼‰æ—¶ä»å†…å­˜ä¸­é‡Šæ”¾å®ƒä»¬ã€‚"
}, {
  "tag": "P",
  "text": "Thatâ€™s it. DI in general and Dagger2, in particular, are huge subjects that really deserve their own blog post (or two) so Iâ€™ll leave it at that.",
  "translation": "è€Œå·²ã€‚ æ€»ä½“è€Œè¨€ï¼ŒDIå°¤å…¶æ˜¯Dagger2æ˜¯çœŸæ­£å€¼å¾—æ‹¥æœ‰è‡ªå·±çš„åšå®¢æ–‡ç« ï¼ˆæˆ–ä¸¤ç¯‡ï¼‰çš„åºå¤§ä¸»é¢˜ï¼Œå› æ­¤æˆ‘å°†å…¶ä¿ç•™ã€‚"
}, {
  "tag": "P",
  "text": "Time to talk about testing again.",
  "translation": "æ˜¯æ—¶å€™å†è°ˆè®ºæµ‹è¯•äº†ã€‚"
}, {
  "tag": "H2",
  "text": "Testing the presenters",
  "translation": "æµ‹è¯•æ¼”ç¤ºè€…"
}, {
  "tag": "P",
  "text": "Testing the presenters is as simple as invoking an action, and asserting that the ViewState updates match our expectations.",
  "translation": "æµ‹è¯•æ¼”ç¤ºè€…å°±åƒè°ƒç”¨ä¸€ä¸ªåŠ¨ä½œä¸€æ ·ç®€å•ï¼Œå¹¶ä¸”æ–­è¨€ViewStateæ›´æ–°ç¬¦åˆæˆ‘ä»¬çš„æœŸæœ›ã€‚"
}, {
  "tag": "P",
  "text": "Hereâ€™s a small part of PopularMoviesViewModel tests suit:",
  "translation": "è¿™æ˜¯PopularMoviesViewModelæµ‹è¯•å¥—è£…çš„ä¸€å°éƒ¨åˆ†ï¼š"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/mrsegev/74ceb56a8f6590cfdf90a87068bf62ac/raw/a4d85ecd366b74a9bf17f482416fbe235fc74842/movienight-popularMovies-tests.kt",
  "code": "@Before\n@UiThreadTest\nfun before() {\n    moviesRepository = Mockito.mock(MoviesRepository::class.java)\n    val getPopularMoviesUseCase = GetPopularMovies(TestTransformer(), moviesRepository)\n    popularMoviesViewModel = PopularMoviesViewModel(getPopularMoviesUseCase, movieEntityMovieMapper)\n    viewObserver = mock(Observer::class.java) as Observer<PopularMoviesViewState>\n    errorObserver = mock(Observer::class.java) as Observer<Throwable?>\n    popularMoviesViewModel.viewState.observeForever(viewObserver)\n    popularMoviesViewModel.errorState.observeForever(errorObserver)\n}\n\n@Test\n@UiThreadTest\nfun testShowingMoviesAsExpectedAndStopsLoading() {\n    val movieEntities = DomainTestUtils.generateMovieEntityList()\n    `when`(moviesRepository.getMovies()).thenReturn(Observable.just(movieEntities))\n    popularMoviesViewModel.getPopularMovies()\n    val movies = movieEntities.map { movieEntityMovieMapper.mapFrom(it) }\n\n    verify(viewObserver).onChanged(PopularMoviesViewState(showLoading = false, movies = movies))\n    verify(errorObserver).onChanged(null)\n}"
}, {
  "tag": "P",
  "text": "In the example above Iâ€™m mocking all the dependencies using Mockito, calling getPopularMovies() method, and finally â€” verifying my mock observer got invoked with updated ViewState with specific parameters.",
  "translation": "åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä½¿ç”¨Mockitoæ¨¡æ‹Ÿæ‰€æœ‰ä¾èµ–é¡¹ï¼Œè°ƒç”¨getPopularMoviesï¼ˆï¼‰æ–¹æ³•ï¼Œæœ€å-éªŒè¯æˆ‘çš„æ¨¡æ‹Ÿè§‚å¯Ÿå™¨æ˜¯å¦å·²ä½¿ç”¨å…·æœ‰ç‰¹å®šå‚æ•°çš„æ›´æ–°ViewStateè¿›è¡Œäº†è°ƒç”¨ã€‚"
}, {
  "tag": "H1",
  "text": "Andâ€¦ Thatâ€™s it!",
  "translation": "è€Œä¸”...å°±æ˜¯è¿™æ ·ï¼"
}, {
  "tag": "P",
  "text": "Phew! That was a long post but, Iâ€™m pretty sure that by now, Iâ€™ve covered all the things I wanted to write about. This blog post aimed to highlight some of the interesting parts of MovieNight code base and some of the decisions Iâ€™ve made.",
  "translation": "ï¼ é‚£æ˜¯ä¸€ç¯‡å¾ˆé•¿çš„æ–‡ç« ï¼Œä½†æ˜¯ï¼Œæˆ‘å¾ˆç¡®å®šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘å·²ç»æ¶µç›–äº†æ‰€æœ‰æˆ‘æƒ³å†™çš„ä¸œè¥¿ã€‚ è¿™ç¯‡åšå®¢æ–‡ç« æ—¨åœ¨é‡ç‚¹ä»‹ç»MovieNightä»£ç åº“ä¸­ä¸€äº›æœ‰è¶£çš„éƒ¨åˆ†ä»¥åŠæˆ‘åšå‡ºçš„ä¸€äº›å†³å®šã€‚"
}, {
  "tag": "P",
  "text": "I hope you found the topics and ideas mentioned here interesting and educating.",
  "translation": "æˆ‘å¸Œæœ›æ‚¨å‘ç°æ­¤å¤„æåˆ°çš„ä¸»é¢˜å’Œæ€æƒ³æœ‰è¶£ä¸”å…·æœ‰æ•™è‚²æ„ä¹‰ã€‚"
}, {
  "tag": "P",
  "text": "Thank you for reading. ğŸ˜„",
  "translation": "æ„Ÿè°¢æ‚¨çš„é˜…è¯»ã€‚ ğŸ˜„"
}, {
  "tag": "PRE",
  "text": "(æœ¬æ–‡ç¿»è¯‘è‡ªYossi Segevçš„æ–‡ç« ã€ŠA Guided Tour inside a clean architecture code base.ã€‹ï¼Œå‚è€ƒï¼šhttps://proandroiddev.com/a-guided-tour-inside-a-clean-architecture-code-base-48bb5cc9fc97)",
  "translation": "ï¼ˆæœ¬æ–‡ç¿»è¯‘è‡ªYossi Segevçš„æ–‡ç« ï¼Œâ€œåœ¨å¹²å‡€çš„å»ºç­‘ä»£ç åº“ä¸­è¿›è¡Œçš„å¯¼è§ˆã€‚â€ï¼Œå‚è€ƒï¼šhttpsï¼š//proandroiddev.com/a-guided-tour-inside-a-clean-architecture-code-base-48bb5cc9fc97 ï¼‰"
}]