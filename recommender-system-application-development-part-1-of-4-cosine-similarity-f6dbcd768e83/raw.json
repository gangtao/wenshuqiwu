[{
  "tag": "H1",
  "text": "Recommender System Application development",
  "translation": "推荐系统应用程序开发"
}, {
  "tag": "H2",
  "text": "With Cosine Similarity, Rating thresholding, and other custom techniques",
  "translation": "使用余弦相似度，评级阈值和其他自定义技术"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*YSDKzjONGi1xB6ub2gidXw.jpeg?q=20",
  "caption": "Source",
  "type": "image",
  "file": "1*YSDKzjONGi1xB6ub2gidXw.jpeg"
}, {
  "tag": "P",
  "text": "In this article we will be developing a Recommender System (RS) using Cosine Similarity (CS) along with other custom formulas with Python programming language. This application will be the part of the project I worked on during my MSc thesis.",
  "translation": "在本文中，我们将使用余弦相似度（CS）以及其他使用Python编程语言的自定义公式来开发推荐系统（RS）。 该应用程序将是我在MSc论文期间从事的项目的一部分。"
}, {
  "tag": "P",
  "text": "There are many ways of building a RS. Here we will develop methods to particularly tackle Cold Start problem for RSs. Cold Start problem is the difficulty of making recommendations for a user without having a lot of information about them (a newly registered user). In this project, we will investigate the ways of making recommendations with only a few information about the user (allowing them to select a category they are interested in).",
  "translation": "建立RS的方法有很多。 在这里，我们将开发一些方法来特别解决RS的冷启动问题。 冷启动问题是难以在没有大量关于用户（新注册用户）的信息的情况下为用户提出建议的困难。 在这个项目中，我们将研究仅使用有关用户的少量信息（允许他们选择他们感兴趣的类别）进行推荐的方法。"
}, {
  "tag": "P",
  "text": "Requirements:",
  "translation": "要求："
}, {
  "tag": "UL",
  "texts": ["Python 3", "numpy", "pandas", "nltk"],
  "translations": ["Python 3", "麻木", "大熊猫", "lt"]
}, {
  "tag": "P",
  "text": "I will assume you know Python throughout the development process of these articles. I will not be focusing nor describing the Python code in detail as the main purpose of these articles to teach about using CS and other techniques to build a RS. It is also worth mentioning that there might be some code that I will write which could have been better as I am not a Python guru. If you realize such parts, please do let me know in comments so I can refactor it later :)",
  "translation": "我将假设您在这些文章的整个开发过程中都了解Python。 这些文章的主要目的是讲授如何使用CS和其他技术来构建RS，因此我不会重点介绍Python代码。 还值得一提的是，我可能会编写一些代码，由于我不是Python专家，所以可能会更好。 如果您意识到这些部分，请在评论中让我知道，以便稍后进行重构:)"
}, {
  "tag": "P",
  "text": "We will develop 4 different versions to investigate a different approach to improve our system with each one of them. Firstly we will start with a recommender system with Cosine Similarity.",
  "translation": "我们将开发4个不同的版本，以研究一种不同的方法来改进我们的系统。 首先，我们将从具有余弦相似性的推荐系统开始。"
}, {
  "tag": "P",
  "text": "The RS we are going to built, is going to recommend 5 different cities for travelling with respect to selected category. Of course these techniques and methods can later be applied for applications with different contexts.",
  "translation": "我们将建立的RS将针对所选类别推荐5个不同的城市出行。 当然，这些技术和方法以后可以应用于具有不同上下文的应用程序。"
}, {
  "tag": "P",
  "text": "Please download the dataset that our RS will be based on here.",
  "translation": "请在此处下载我们的RS将基于的数据集。"
}, {
  "tag": "P",
  "text": "Some of the features (columns) of this dataset are genuine information that I previously acquired from TripAdvisor website, while some of them are just random features that I have added to implement and display different techniques later on. Our dataset consists of 25 cities with the following features: city, popularity, description, image, rating, rating_count, positive_review, negative_review. You can see the preview of the dataset for the first 5 cities below.",
  "translation": "该数据集的某些功能（列）是我以前从TripAdvisor网站获得的真实信息，而其中一些只是我添加的随机功能，以在以后实现和显示不同的技术。 我们的数据集由25个城市组成，这些城市具有以下特征：城市，受欢迎程度，描述，图像，等级，等级数，肯定评论，否定评论。 您可以在下面查看前5个城市的数据集预览。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*8QpIA9ujHIeKUj0tcIXlqg.png?q=20",
  "caption": "City dataset preview",
  "type": "image",
  "file": "1*8QpIA9ujHIeKUj0tcIXlqg.png"
}, {
  "tag": "P",
  "text": "Features that I have acquired from TripAdvisor are: city, popularity, description and image. The features other than these are crafted randomly by me. We wont be using those features for the first version of the RS but they will be used for different techniques on other parts of these series.",
  "translation": "我从TripAdvisor获得的功能包括：城市，受欢迎程度，描述和图像。 除这些功能外，其他功能均由我随机制作。 我们不会在RS的第一个版本中使用这些功能，但是这些功能将用于这些系列其他部分的不同技术。"
}, {
  "tag": "P",
  "text": "Lets review what each feature stands for:",
  "translation": "让我们回顾一下每个功能代表什么："
}, {
  "tag": "UL",
  "texts": ["city: City name", "popularity: Review count saved for the city.", "description: Blog post about the city", "image: Background image for the city", "rating: Average rating value for the city (0–10)", "rating_count: Amount of ratings received from users", "postive_review: Amount of positive reviews.", "negative_review: Amount of negative reviews."],
  "translations": ["城市：城市名称", "受欢迎程度：为该城市保存的评论数。", "描述：有关城市的博客文章", "图片：城市的背景图片", "评分：城市的平均评分值（0–10）", "rating_count：从用户那里收到的评分数量", "postive_review：正面评论的数量。", "negative_review：负面评论数量。"]
}, {
  "tag": "P",
  "text": "Now that we have downloaded our dataset and learnt about the features, we can get started with the development. As mentioned earlier, we will use only the city and description features for the first version.",
  "translation": "现在我们已经下载了数据集并了解了功能，接下来就可以开始开发了。 如前所述，我们仅将城市和说明功能用于第一个版本。"
}, {
  "tag": "H1",
  "text": "Version-1",
  "translation": "版本1"
}, {
  "tag": "P",
  "text": "The first version of the RS will be giving recommendations based on the description feature of the cities in our dataset. RS will calculate the similarity between the description of the cities and the keywords related to a trip category that a user may select, with Cosine Similarity and then return the top 5 cities with highest similarity score.",
  "translation": "RS的第一版将根据数据集中城市的描述特征给出建议。 RS将使用余弦相似度计算城市描述和与用户可以选择的旅行类别相关的关键字之间的相似度，然后返回相似度得分最高的前5个城市。"
}, {
  "tag": "H2",
  "text": "Cosine Similarity",
  "translation": "余弦相似度"
}, {
  "tag": "P",
  "text": "Cosine similarity is the measure of similarity between two vectors, by computing the cosine of the angle between two vectors projected into multidimensional space. It can be applied to items available on a dataset to compute similarity to one another via keywords or other metrics. Similarity between two vectors (A and B) is calculated by taking the dot product of the two vectors and dividing it by the magnitude value as shown in the equation below. We can simply say that the CS score of two vectors increases as the angle between them decreases.",
  "translation": "余弦相似度是通过计算投影到多维空间中的两个向量之间的角度的余弦值来度量两个向量之间相似度的方法。 可以将其应用于数据集中可用的项目，以通过关键字或其他指标来计算彼此之间的相似度。 通过取两个向量的点积并将其除以幅度值，可以计算出两个向量（A和B）之间的相似度，如下式所示。 我们可以简单地说两个向量的CS分数随着它们之间的夹角的减小而增加。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*nUNJaIHpUoPozJxe5HZ-fg.png?q=20",
  "caption": "Cosine Similarity Calculation for vectors A and B",
  "type": "image",
  "file": "1*nUNJaIHpUoPozJxe5HZ-fg.png"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*GjsUmEEOyKaCir54CuvwUQ.png?q=20",
  "caption": "Similarity between vectors A and B on 3-dimensional space",
  "type": "image",
  "file": "1*GjsUmEEOyKaCir54CuvwUQ.png"
}, {
  "tag": "H2",
  "text": "Preprocessing",
  "translation": "预处理"
}, {
  "tag": "P",
  "text": "First of all we need to do some preprocessing to our dataset to make it ready for using in our CS calculation methods. Lets create a python file named pre_processing.py in a folder including the dataset.",
  "translation": "首先，我们需要对数据集进行一些预处理，以准备将其用于CS计算方法中。 让我们在包含数据集的文件夹中创建一个名为pre_processing.py的python文件。"
}, {
  "tag": "P",
  "text": "We are only going to clear description feature of our dataset. We need to remove stop words from the descriptions. Stop words are the words without any contextual meaning, such as; the, for, an, a, or, what and etc. The motivation behind removing these words is to make sure the similarity score later will not be decreased due to non-contextual words. It would affect the score negatively since each word creates a different dimension in the space and the corresponding value for these dimensions would always be zero since none of our keywords will include non-contextual words.",
  "translation": "我们只会清除数据集的描述功能。 我们需要从描述中删除停用词。 停用词是没有任何上下文意义的词，例如； 删除这些词的动机是确保以后不会由于非上下文词而降低相似度得分。 这将对分数产生负面影响，因为每个单词都会在空间中创建一个不同的维度，并且这些维度的相应值将始终为零，因为我们的关键字都不会包含非上下文的单词。"
}, {
  "tag": "PRE",
  "text": "import numpy as npimport pandas as pdfrom nltk.corpus import stopwordsdef clear(city):    city = city.lower()    city = city.split()    city_keywords = [word for word in city if word not in stopwords.words('english')]    merged_city = \" \".join(city_keywords)    return merged_city",
  "translation": "导入numpy为np导入熊猫为pdfrom nltk.corpus导入stopwordsdef clear（city）：city = city.lower（）city = city.split（）city_keywords = [如果单词不在stopwords.words（'english' ）] merged_city =“” .join（city_keywords）返回merged_city"
}, {
  "tag": "P",
  "text": "We will be cleaning city descriptions with clear(city) method above. It works as following:",
  "translation": "我们将使用上面的clear（city）方法清除城市描述。 它的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["It takes a String parameter called city", "Lowers each character of string with .lower() method.", "Creates a list of words with .split() method.", "Initializes city_keywords by removing stopwords for english language (nltk framework)", "Merges a String back from the cleared words and returns it"],
  "translations": ["它需要一个名为city的String参数", "使用.lower（）方法降低字符串的每个字符。", "使用.split（）方法创建单词列表。", "通过删除英语的停用词来初始化city_keywords（nltk框架）", "从清除的单词中合并一个字符串并返回"]
}, {
  "tag": "P",
  "text": "Now lets apply this method to every entry in our dataset as following:",
  "translation": "现在，将这种方法应用于数据集中的每个条目，如下所示："
}, {
  "tag": "PRE",
  "text": "for index, row in df.iterrows():    clear_desc = clear(row['description'])    df.at[index, 'description'] = clear_descupdated_dataset = df.to_csv('city_data_cleared.csv')",
  "translation": "对于索引，在df.iterrows（）中的行：clear_desc = clear（row ['description']）df.at [index，'description'] = clear_descupdated_dataset = df.to_csv（'city_data_cleared.csv'）"
}, {
  "tag": "P",
  "text": "This code block will clear all the descriptions for all the cities on our dataset and then saves the updated one as city_data_cleared.csv file. From now on we will be using this cleared data set.",
  "translation": "此代码块将清除数据集中所有城市的所有描述，然后将更新的城市另存为city_data_cleared.csv文件。 从现在开始，我们将使用此清除的数据集。"
}, {
  "tag": "P",
  "text": "pre_processing.py gist:",
  "translation": "pre_processing.py要点："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/725f0a9e8e18465ba2098a34af8b6be2/raw/050bef2248d810eb6b444682b2f640469da79bda/pre_processing.py",
  "code": "import numpy as np\nimport pandas as pd\nfrom nltk.corpus import stopwords\n\ndf = pd.read_csv('city_data.csv')\n\ndef clear(city):\n    city = city.lower()\n    city = city.split()\n    city_keywords = [word for word in city if word not in stopwords.words('english')]\n    \n    merged_city = \" \".join(city_keywords)\n    return merged_city\n\nfor index, row in df.iterrows():\n    clear_desc = clear(row['description'])\n    df.at[index, 'description'] = clear_desc\n\nupdated_dataset = df.to_csv('city_data_cleared.csv')\n"
}, {
  "tag": "H2",
  "text": "Similarity score calculation with Cosine Similarity",
  "translation": "余弦相似度计算相似度"
}, {
  "tag": "P",
  "text": "Now that we have cleared city descriptions, we can start implementing the class which will be responsible for calculating the similarity score. Lets’s create a python file named cosine_similarity.py.",
  "translation": "现在我们已经清除了城市描述，我们可以开始实现将用于计算相似性得分的类。 让我们创建一个名为cosine_similarity.py的python文件。"
}, {
  "tag": "P",
  "text": "As I have mentioned earlier, the method will compute the similarity of two strings depending on the words they have. First, both these Strings will be converted to vectors, and then each word in a vector will create a dimension on the word space. If any word that exists in one does not exist on the other, the value for the corresponding dimension for the other vector will be zero.",
  "translation": "如前所述，该方法将根据两个字符串具有的单词来计算它们的相似度。 首先，这两个字符串都将转换为向量，然后向量中的每个单词都会在单词空间上创建一个维。 如果一个单词中不存在另一个单词，则另一个向量的相应维的值将为零。"
}, {
  "tag": "P",
  "text": "Not: Cosine similarity is scale invariant, meaning; it is not that much affected by the amount of how many times a word exists in a given string. We are using cosine similarity regardless, since we only care if a word exists on both strings, we do not care how many times a word occurs. But if you would be interested for such count difference and would like your recommender to take that into account (which means the score will be greatly affected by word occurrence) then I would suggest you to check out Pearson correleation.",
  "translation": "不是：余弦相似度是尺度不变的，意思是； 单词在给定字符串中存在多少次的影响并不大。 无论如何，我们都使用余弦相似度，因为我们只关心两个字符串上是否都存在一个单词，所以我们不在乎一个单词出现了多少次。 但是，如果您对这种计数差异感兴趣，并且希望您的推荐者考虑到这一点（这意味着分数会受到单词出现的影响很大），那么我建议您检查一下Pearson相关性。"
}, {
  "tag": "P",
  "text": "Even though there is only going to be one method for computation, let us create it under a class to improve usability for later.",
  "translation": "即使只有一种计算方法，让我们在一个类下创建它以提高以后的可用性。"
}, {
  "tag": "PRE",
  "text": "import re, mathfrom collections import Counterclass CosineSimilarity:    def __init__(self):        print(\"Cosine Similarity initialized\")        @staticmethod    def cosine_similarity_of(text1, text2):        first = re.compile(r\"[\\w']+\").findall(text1)        second = re.compile(r\"[\\w']+\").findall(text2)        vector1 = Counter(first)        vector2 = Counter(second)        common = set(vector1.keys()).intersection(set(vector2.keys()))        dot_product = 0.0        for i in common:                      dot_product += vector1[i] * vector2[i]        squared_sum_vector1 = 0.0        squared_sum_vector2 = 0.0        for i in vector1.keys():            squared_sum_vector1 += vector1[i]**2        for i in vector2.keys():            squared_sum_vector2 += vector2[i]**2        magnitude = math.sqrt(squared_sum_vector1) * math.sqrt(squared_sum_vector2)        if not magnitude:           return 0.0        else:           return float(dot_product) / magnitude",
  "translation": "import re，mathfrom集合import Counterclass CosineSimilarity：def __init __（self）：print（“ Cosine相似性已初始化”）@staticmethod def cosine_similarity_of（text1，text2）：first = re.compile（r“ [\\ w'] +”）。 findall（text1）second = re.compile（r“ [\\ w'] +”）。findall（text2）vector1 = Counter（first）vector2 = Counter（second）common = set（vector1.keys（））。intersection（ set（vector2.keys（）））dot_product = 0.0 for i in common：dot_product + = vector1 [i] * vector2 [i] squared_sum_vector1 = 0.0 squared_sum_vector2 = 0.0 for i in vector1.keys（）：squared_sum_vector1 + = vector1 [i ] ** 2 for vector2.keys（）中的i：squared_sum_vector2 + = vector2 [i] ** 2幅度= math.sqrt（squared_sum_vector1）* math.sqrt（squared_sum_vector2）如果不是幅度：返回0.0否则：返回float（dot_product ）/大小"
}, {
  "tag": "P",
  "text": "cosine_similarity_of method works as following:",
  "translation": "cosine_similarity_of方法的工作原理如下："
}, {
  "tag": "UL",
  "texts": ["Takes two string parameters", "Gets words for both strings with the help of Regex", "Initializes a dictionary with Counter (words, word count), where keys correspond to a word and value to the count of that particular word.", "Gets common words that exist in both vectors", "Calculates the cosine similarity by following the formula that was introduced under Cosine Similarity section and returns the value."],
  "translations": ["接受两个字符串参数", "在正则表达式的帮助下获取两个字符串的单词", "使用计数器（单词，单词计数）初始化字典，其中键对应于一个单词，值对应于该特定单词的计数。", "获取两个向量中都存在的常用词", "通过遵循在“余弦相似度”部分下引入的公式来计算余弦相似度并返回值。"]
}, {
  "tag": "P",
  "text": "cosine_similarity.py gist:",
  "translation": "cosine_similarity.py要点："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/ea480c6e6eaf073814732d21a0912458/raw/e50702f88fb66abdcc6ddfada44f65c01c632e14/cosine_similarity.py",
  "code": "import re, math\nfrom collections import Counter\n\nclass CosineSimilarity:\n    def __init__(self):\n        print(\"Cosine Similarity initialized\")\n\n    @staticmethod\n    def cosine_similarity_of(text1, text2):\n        #get words first\n        first = re.compile(r\"[\\w']+\").findall(text1)\n        second = re.compile(r\"[\\w']+\").findall(text2)\n\n        #get dictionary with each word and count.\n        vector1 = Counter(first)\n        vector2 = Counter(second)\n\n        #convert vectors to set to find common words as intersection\n        common = set(vector1.keys()).intersection(set(vector2.keys()))\n\n        dot_product = 0.0\n\n        for i in common:\n            #get amount of each common word for both vectors and multiply them then add them together.\n            dot_product += vector1[i] * vector2[i]\n\n        squared_sum_vector1 = 0.0\n        squared_sum_vector2 = 0.0\n\n        #get squared sum values of word counts from each vector.\n        for i in vector1.keys():\n            squared_sum_vector1 += vector1[i]**2\n\n        for i in vector2.keys():\n            squared_sum_vector2 += vector2[i]**2\n\n        #calculate magnitude with squared sums.\n        magnitude = math.sqrt(squared_sum_vector1) * math.sqrt(squared_sum_vector2)\n\n        if not magnitude:\n           return 0.0\n        else:\n           return float(dot_product) / magnitude\n"
}, {
  "tag": "H2",
  "text": "Recommender Engine",
  "translation": "推荐引擎"
}, {
  "tag": "P",
  "text": "Next, we will write the engine that will be responsible for making recommendations.",
  "translation": "接下来，我们将编写负责提出建议的引擎。"
}, {
  "tag": "P",
  "text": "The engine class is going to be small since, in the version-1 we will only make recommendations by comparing keywords and city descriptions, but we will have it as a separate class regardless, since we will be iterating over it and develop during other versions in the next parts of these series.",
  "translation": "引擎类将很小，因为在版本1中，我们只会通过比较关键字和城市描述来提出建议，但是无论如何我们都将其作为单独的类，因为我们将对其进行迭代并在其他版本中进行开发 在这些系列的下一部分中。"
}, {
  "tag": "P",
  "text": "recommender_engine.py:",
  "translation": "Recommendationer_engine.py："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/9d946bbdbc58e3bc93bb79bc9c3572d6/raw/f68e8480bbeae18d1be8f81838d024082dcb7330/recommender_engine.py",
  "code": "import numpy as np\nimport pandas as pd\nfrom cosine_similarity import CosineSimilarity\nimport operator\nimport json\n\nclass RecommenderEngine:\n    def __init__(self):\n        print(\"engine initialized\")\n\n    def get_recommendations(keywords):\n\n        df = pd.read_csv('city_data_cleared.csv')\n\n        score_dict = {}\n\n        for index, row in df.iterrows():\n            score_dict[index] = CosineSimilarity.cosine_similarity_of(row['description'], keywords)\n\n        #sort cities by score and index.\n        sorted_scores = sorted(score_dict.items(), key=operator.itemgetter(1), reverse=True)\n\n        counter = 0\n\n        #create an empty results data frame.\n        resultDF = pd.DataFrame(columns=('city', 'popularity', 'description', 'score'))\n\n        #get highest scored 5 cities.\n        for i in sorted_scores:\n            #print index and score of the city.\n            #print(i[0], i[1])\n            resultDF = resultDF.append({'city': df.iloc[i[0]]['city'], 'popularity': df.iloc[i[0]]['popularity'], 'description': df.iloc[i[0]]['description'], 'score': i[1]}, ignore_index=True)\n            counter += 1\n\n            if counter>4:\n                break\n\n        #convert DF to json.\n        json_result = json.dumps(resultDF.to_dict('records'))\n        return json_result\n"
}, {
  "tag": "P",
  "text": "get_recommendations(keywords) method works as following:",
  "translation": "get_recommendations（keywords）方法的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["Accepts a string parameter to compute cosine similarity of city descriptions with", "Computes the CS for each city with the given parameter and saves it as a dictionary as <city index, score>", "Creates an empty data frame with the features of city, popularity, description and score.", "Adds the top scoring 5 cities to this data frame", "Converts data frame to JSON and returns it."],
  "translations": ["接受字符串参数以计算城市描述的余弦相似度", "使用给定参数为每个城市计算CS，并将其另存为字典作为<city index，score>", "创建一个具有城市，受欢迎程度，描述和得分等特征的空数据框。", "将得分最高的5个城市添加到此数据框中", "将数据帧转换为JSON并返回。"]
}, {
  "tag": "H2",
  "text": "Request code",
  "translation": "请求代码"
}, {
  "tag": "P",
  "text": "Now we will test our engine (and CS computing function along with it). Lets create a request.py python file.",
  "translation": "现在，我们将测试引擎（以及CS计算功能）。 让我们创建一个request.py python文件。"
}, {
  "tag": "P",
  "text": "We will be testing our recommender engine under three different categories:",
  "translation": "我们将在三种不同的类别下测试推荐引擎："
}, {
  "tag": "UL",
  "texts": ["Culture, Art and History", "Beach and Sun", "Nightlife and Party"],
  "translations": ["文化，艺术与历史", "海滩和太阳", "夜生活和派对"]
}, {
  "tag": "P",
  "text": "I have investigated the descriptions of all the cities in our dataset and determined the keywords for each category manually as following:",
  "translation": "我调查了数据集中所有城市的描述，并手动确定了每个类别的关键字，如下所示："
}, {
  "tag": "UL",
  "texts": ["[history historical art architecture city culture]", "[beach beaches park nature holiday sea seaside sand sunshine sun sunny]", "[nightclub nightclubs nightlife bar bars pub pubs party beer]"],
  "translations": ["[历史史艺术建筑城市文化]", "[海滩公园自然假期海边沙滩阳光阳光明媚]", "[夜总会夜总会夜生活酒吧酒吧酒馆酒吧聚会啤酒]"]
}, {
  "tag": "P",
  "text": "Let’s add the following code which will send a request to get top 5 similar cities for the given keyword, along with predefined keywords:",
  "translation": "让我们添加以下代码，该代码将发送请求，以获取给定关键字以及预定义关键字的前5个类似城市："
}, {
  "tag": "PRE",
  "text": "from recommender_engine import RecommenderEngineculture_keywords = \"history historical art architecture city culture\"beach_n_sun_keywords = \"beach beaches park nature holiday sea seaside sand sunshine sun sunny\"nightlife_keywords = \"nightclub nightclubs nightlife bar bars pub pubs party beer\"def get_recommendations(keywords):    result = RecommenderEngine.get_recommendations(keywords)    return result",
  "translation": "从recommender_engine导入RecommenderEngineculture_keywords =“历史历史艺术建筑城市文化” beach_n_sun_keywords =“海滩自然假日海边海边沙滩阳光明媚的阳光” nightlife_keywords =“夜总会夜总会夜生活酒吧酒吧酒馆酒吧聚会啤酒” def get_recommendations（关键字）：结果=建议 .get_recommendations（keywords）返回结果"
}, {
  "tag": "P",
  "text": "Then lets write a helper method to get city names and score from a JSON as following:",
  "translation": "然后，让我们编写一个辅助方法，以从JSON获取城市名称和得分，如下所示："
}, {
  "tag": "PRE",
  "text": "def get_top_5_city_names_out_of_json(json_string):    list = json.loads(json_string)    result = []    max = len(list)    i = 0    while i < max:        result.append(list[i]['city'])        i += 1    return result",
  "translation": "def get_top_5_city_names_out_of_json（json_string）：list = json.loads（json_string）result = [] max = len（list）i = 0，而我<max：result.append（list [i] ['city']）i + = 1 返回结果"
}, {
  "tag": "P",
  "text": "Now we will make 3 requests to the recommender for the 3 categories and then print top 5 cities along with their similarity score for each category:",
  "translation": "现在，我们将向3个类别的推荐者发出3个请求，然后打印前5个城市以及每个类别的相似度得分："
}, {
  "tag": "PRE",
  "text": "top_5_cultural_cities = get_recommendations(culture_keywords)city_names_for_cultural = get_top_5_city_names_out_of_json(top_5_cultural_cities)print(city_names_for_cultural)print(\"#################\")top_5_summer_cities = get_recommendations(beach_n_sun_keywords)city_names_for_summer = get_top_5_city_names_out_of_json(top_5_summer_cities)print(city_names_for_summer)print(\"#################\")top_5_party_cities = get_recommendations(nightlife_keywords)city_names_for_party = get_top_5_city_names_out_of_json(top_5_party_cities)print(city_names_for_party)print(\"#################\")",
  "translation": "top_5_cultural_cities= get_recommendations（culture_keywords）city_names_for_cultural= get_top_5_city_names_out_of_json（top_5_cultural_cities）打印（city_names_for_cultural）打印（ “#################”）top_5_summer_cities= get_recommendations（beach_n_sun_keywords）city_names_for_summer= get_top_5_city_names_out_of_json（top_5_summer_cities） print（city_names_for_summer）print（“ #################”）top_5_party_cities = get_recommendations（nightlife_keywords）city_names_for_party = get_top_5_city_names_out_of_json（top_5_party_party_cities）print ## city ############“）"
}, {
  "tag": "P",
  "text": "We will get recommendations for all 3 categories when we run the code, but lets investigate the results we get only for Culture, Art and History category:",
  "translation": "运行代码时，我们将为所有3个类别提供建议，但让我们调查仅从文化，艺术和历史类别获得的结果："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.21629522817435007), ('St. Petersburg', 0.16666666666666666), ('Stockholm', 0.14962640041614492), ('Milan', 0.140028008402801), ('Rome', 0.12171612389003691)]",
  "translation": "[（'雅典'，0.21629522817435007，（'圣彼得堡'，0.16666666666666666），（'斯德哥尔摩'，0.14962640041614492），（'米兰'，0.140028008402801），（'罗马'，0.12171612389003691）]"
}, {
  "tag": "P",
  "text": "As shown above, the similarity score is 21.6% for Athens while it is 12.17% for Rome. Scores might have been resulted less than you would expect. The scores are lower because, each city description naturally has more words than the keywords we have provided for comparison. Different words create different dimensions on the space and since our keywords do not have these words, the corresponding value for these dimensions will be zero which results in a lower similarity score. If you add/subtract words from the keywords, you will see the results will change as well.",
  "translation": "如上所示，雅典的相似度得分为21.6％，而罗马的相似度得分为12.17％。 分数产生的结果可能比您预期的要少。 得分较低是因为，每个城市描述中的单词自然比我们提供的用于比较的关键字更多。 不同的单词会在空间上创建不同的维度，并且由于我们的关键字没有这些单词，因此这些维度的对应值将为零，这会导致相似度得分较低。 如果您从关键字中添加/减去单词，您将看到结果也将发生变化。"
}, {
  "tag": "P",
  "text": "request.py gist:",
  "translation": "request.py要点："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/76134355e1dc1509f69f13dce76df96e/raw/5ecafe2decdc425aa53347f4e6470e47a6019166/request.py",
  "code": "from recommender_engine import RecommenderEngine\nimport json\n\nculture_keywords = \"history historical art architecture city culture\"\nbeach_n_sun_keywords = \"beach beaches park nature holiday sea seaside sand sunshine sun sunny\"\nnightlife_keywords = \"nightclub nightclubs nightlife bar bars pub pubs party beer\"\n\ndef get_recommendations(keywords):\n    result = RecommenderEngine.get_recommendations(keywords)\n    return result\n\ndef get_top_5_city_names_out_of_json(json_string):\n    list = json.loads(json_string)\n    result = []\n    max = len(list)\n    i = 0\n    while i < max:\n        result.append((list[i]['city'], list[i]['score']))\n        i += 1\n\n    return result\n\ntop_5_cultural_cities = get_recommendations(culture_keywords)\ncity_names_for_cultural = get_top_5_city_names_out_of_json(top_5_cultural_cities)\nprint(city_names_for_cultural)\nprint(\"#################\")\ntop_5_summer_cities = get_recommendations(beach_n_sun_keywords)\ncity_names_for_summer = get_top_5_city_names_out_of_json(top_5_summer_cities)\nprint(city_names_for_summer)\nprint(\"#################\")\ntop_5_party_cities = get_recommendations(nightlife_keywords)\ncity_names_for_party = get_top_5_city_names_out_of_json(top_5_party_cities)\nprint(city_names_for_party)\nprint(\"#################\")\n"
}, {
  "tag": "H2",
  "text": "Conclusion for Version-1",
  "translation": "版本1的结论"
}, {
  "tag": "P",
  "text": "In this version, we have developed a recommender application that makes city recommendation for traveling for three different categories, by computing the cosine similarity of city descriptions with the given category’s keywords.",
  "translation": "在此版本中，我们开发了一种推荐应用程序，可通过计算给定类别关键字的城市描述的余弦相似度，为三个不同类别的旅行提供城市推荐。"
}, {
  "tag": "P",
  "text": "Even if the similarity scores are low, when you investigate the returned top 5 cities for each category; you can see that our recommender system, recommends meaningful and appropriate cities. You might as well read the city descriptions to verify :)",
  "translation": "即使相似性分数很低，当您调查每个类别返回的前5个城市时； 您会看到我们的推荐系统会推荐有意义且适当的城市。 您不妨阅读城市说明以进行验证:)"
}, {
  "tag": "P",
  "text": "We have came to the end of our first version. You can access all the code written for the first version from here.",
  "translation": "我们到了第一个版本的结尾。 您可以从此处访问为第一个版本编写的所有代码。"
}, {
  "tag": "P",
  "text": "In the next version below, we will implement a different method to calculate a score both including cosine similarity and Rating information of the cities.",
  "translation": "在下面的下一个版本中，我们将采用一种不同的方法来计算分数，包括得分的余弦相似度和城市的等级信息。"
}, {
  "tag": "H1",
  "text": "Version-2 (Rating Contribution)",
  "translation": "版本2（评分贡献）"
}, {
  "tag": "P",
  "text": "In this version we will make use of rating feature of our dataset and improve our recommender application to be more dynamic and make better recommendations. We wouldn’t like to build a system which recommends content with low rating right? At least not in most cases :)",
  "translation": "在此版本中，我们将利用数据集的评分功能，并改进推荐程序，使其更具动态性并提出更好的建议。 我们不想建立一个推荐低评级内容的系统吗？ 至少在大多数情况下不是：)"
}, {
  "tag": "H2",
  "text": "Final Score generation with CS and Rating contribution",
  "translation": "通过CS和Rating贡献产生最终分数"
}, {
  "tag": "P",
  "text": "At first, we will omit the rating quantity. We will still calculate the cosine similarity but now on top of it we will have rating contribution to the final score. We will create a new method which will determine the contribution of rating to the final score. We will have two parameters, Q and r. Where r will represent the rating and Q will represent the importance (weight of rating for final score computation). By playing with the Q parameter, we will be able to increase or decrease the affect of rating value for the final score generation.",
  "translation": "首先，我们将省略额定数量。 我们仍将计算余弦相似度，但现在最重要的是，我们将对最终分数进行评分。 我们将创建一种新方法，该方法将确定评分对最终分数的贡献。 我们将有两个参数Q和r。 其中，r代表评分，Q代表重要性（最终评分计算的评分权重）。 通过使用Q参数，我们将能够增加或减少评级值对最终分数生成的影响。"
}, {
  "tag": "P",
  "text": "New function will either increase or decrease the output of cosine similarity depending on, if the rating is greater or less than 5 proportionally to the given Q parameter (assuming cities with average rating less than 5 is disliked and should be discouraged and greater than 5 is liked and should be encouraged for recommendation. As mentioned in the previous chapter, the rating range is between 0–10 and rating contribution output range is between -Q and +Q.",
  "translation": "新功能将增加或减少余弦相似度的输出，具体取决于等级是否与给定的Q参数成正比（大于或小于5）（假设不喜欢平均等级小于5的城市，应劝阻这些城市，大于5的城市 如上一章所述，额定范围在0-10之间，额定贡献输出范围在-Q和+ Q之间。"
}, {
  "tag": "P",
  "text": "For example: If Q is given as 10, the maximum rating value can produce the final recommendation score by adding 10% of CS score to CS score and for the minimum rating, the final score would be produced by subtracting 10% of CS score from the CS score.",
  "translation": "例如：如果Q设为10，则最大评分值可以通过将CS得分的10％添加到CS得分中来产生最终推荐得分，对于最低评分，可以通过从CS得分中减去10％的CS得分来产生最终推荐得分。 CS分数。"
}, {
  "tag": "P",
  "text": "The formula we will use in the method will find out the exact output for a given rating (finding the exact point on blue line). Visual representation of this rating contribution generator method, for Q = 10 is shown in the figure below:",
  "translation": "我们将在该方法中使用的公式将找出给定额定值的确切输出（在蓝线上找到确切的点）。 下图显示了此额定值贡献生成器方法（对于Q = 10）的直观表示："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*WQkVJMIfz8Iqkg3-hHnabg.png?q=20",
  "caption": "Rating Contribution computer function for Q = 10",
  "type": "image",
  "file": "1*WQkVJMIfz8Iqkg3-hHnabg.png"
}, {
  "tag": "P",
  "text": "Lets create a new file called rating_extractor.py and add the following code",
  "translation": "让我们创建一个名为rating_extractor.py的新文件并添加以下代码"
}, {
  "tag": "PRE",
  "text": "from math import eclass RatingExtractor:    def __init__(self):        print(\"initialized\")#Returns value between -q and q. for rating input between 0 and 10.    #Parameters:        #rating: indicates the rating for the destination        #q: indicates the percentage of rating for general score. (default is 10.)    @staticmethod    def get_rating_weight(rating, q=10):        if rating > 10 or rating < 0:            return None        else:            m = (2*q) / 10 #10 because rating varies between 0 and 10            b = -q            return (m*rating) + b",
  "translation": "从数学导入eclass RatingExtractor：def __init __（self）：print（“ initialized”）＃返回-q和q之间的值。 输入0到10之间的等级。＃参数：#rating：指示目标的等级#q：指示一般分数的等级百分比。 （默认值为10。）@staticmethod def get_rating_weight（rating，q = 10）：如果等级> 10或等级<0：返回其他：m =（2 * q）/ 10＃10，因为等级在0到10 b之间变化 = -q回报率（m *评分）+ b"
}, {
  "tag": "P",
  "text": "get_rating_weight() method does some calculations to determine the contribution output for the given rating and Q parameters and then returns the value. As mentioned earlier and also shown in the figure above, this method can produce both negative and positive values. Meaning; this method will either contribute negatively or positively to the final score calculation. (Please note that the default value of Q parameter is set to 10).",
  "translation": "get_rating_weight（）方法进行一些计算以确定给定评级和Q参数的贡献输出，然后返回该值。 如前所述，也如上图所示，此方法可以产生负值和正值。 含义; 此方法将对最终分数计算产生负面或正面影响。 （请注意，Q参数的默认值设置为10）。"
}, {
  "tag": "H2",
  "text": "Implementing a new method in Recommender Engine",
  "translation": "在推荐引擎中实现新方法"
}, {
  "tag": "P",
  "text": "Now we will add a new method to RecommenderEngine class to calculate a final score using both the cosine similarity score and rating contribution. Add the method below in RecommenderEngine class. (I’ve added right after init).",
  "translation": "现在，我们将向RecommenderEngine类添加一个新方法，以使用余弦相似性评分和评分贡献来计算最终评分。 在RecommenderEngine类中添加以下方法。 （我是在init之后添加的）。"
}, {
  "tag": "PRE",
  "text": "def calculate_final_score(cs, r):    amount = (cs / 100) * r    return cs + amount",
  "translation": "def Calculation_final_score（cs，r）：数量=（cs / 100）* r返回cs +数量"
}, {
  "tag": "P",
  "text": "Method works as the following:",
  "translation": "方法的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["Takes CS score and rating contribution r parameters.", "Calculates +-r percent of CS score in amount variable", "Adds amount to the CS score and returns it."],
  "translations": ["取CS得分和等级贡献r参数。", "计算金额变量中CS分数的+ -r％", "将金额加到CS分数中并返回。"]
}, {
  "tag": "P",
  "text": "As amount can be either positive or negative, final score is either going to be increased or decreased depending on the contribution value.",
  "translation": "由于金额可以是正数或负数，因此最终分数将根据贡献值而增加或减少。"
}, {
  "tag": "P",
  "text": "It is worth mentioning that, this method is highly biased on CS score though. As it operates as taking r percentage of CS and adding it back to original CS value. Cities with higher CS value will be greatly affected by this new final score computation, especially if higher values of Q is given for get_rating_weight() method.",
  "translation": "值得一提的是，这种方法对CS评分的偏向很高。 因为它的作用是取CS的r百分比并将其添加回原始CS值。 具有较高CS值的城市将受到此新的最终得分计算的极大影响，尤其是如果为get_rating_weight（）方法指定了较高的Q值时。"
}, {
  "tag": "P",
  "text": "Now let’s add another method to RecommenderEngine to use this new method for score calculation (we will keep the old recommendation method).",
  "translation": "现在，我们向RecommenderEngine添加另一种方法，以使用此新方法进行得分计算（我们将保留旧的推荐方法）。"
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/0dc8e39238493004cebdcd62e8016ac2/raw/3e21af9ce5a85620247707943fad692a4c762f96/recommender_engine_version2_method.py",
  "code": "import numpy as np\nimport pandas as pd\nfrom cosine_similarity import CosineSimilarity\nfrom rating_extractor import RatingExtractor\nimport operator\nimport json\n\nclass RecommenderEngine:\n    def __init__(self):\n        print(\"engine initialized\")\n\n    def calculate_final_score(cs, r):\n        amount = (cs / 100) * r\n\n        return cs + amount\n\n    # Version-2\n    def get_recommendations_include_rating(keywords):\n        df = pd.read_csv('city_data_cleared.csv')\n\n        score_dict = {}\n\n        for index, row in df.iterrows():\n            cs_score = CosineSimilarity.cosine_similarity_of(row['description'], keywords)\n\n            rating = row['rating']\n            rating_contribution = RatingExtractor.get_rating_weight(rating,10)\n\n            final_score = RecommenderEngine.calculate_final_score(cs_score, rating_contribution)\n\n            score_dict[index] = final_score\n\n        #sort cities by score and index.\n        sorted_scores = sorted(score_dict.items(), key=operator.itemgetter(1), reverse=True)\n\n        counter = 0\n\n        #create an empty results data frame.\n        resultDF = pd.DataFrame(columns=('city', 'popularity', 'description', 'score'))\n\n        #get highest scored 5 cities.\n        for i in sorted_scores:\n            #print index and score of the city.\n            #print(i[0], i[1])\n            resultDF = resultDF.append({'city': df.iloc[i[0]]['city'], 'popularity': df.iloc[i[0]]['popularity'], 'description': df.iloc[i[0]]['description'], 'score': i[1]}, ignore_index=True)\n            counter += 1\n\n            if counter>4:\n                break\n\n        #convert DF to json.\n        json_result = json.dumps(resultDF.to_dict('records'))\n        return json_result"
}, {
  "tag": "P",
  "text": "get_recommendations_include_rating(keywords) method will be working similarly to get_recommendations(keywords) method implemented on the first chapter. But now it will calculate the final score with both CS score and rating contribution value, lets examine how the method works:",
  "translation": "get_recommendations_include_rating（keywords）方法的工作原理与第一章中实现的get_recommendations（keywords）方法类似。 但是现在它将使用CS分数和评分贡献值来计算最终分数，让我们检查一下该方法的工作原理："
}, {
  "tag": "UL",
  "texts": ["Takes keywords parameter and does the following for every city in the dataset", "Computes cs score", "Computes rating contribution score with Q=10", "Computes final score by using both scores in calculate_final_score method", "Gets top 5 cities with highest final score and returns as JSON"],
  "translations": ["获取关键字参数，并对数据集中的每个城市执行以下操作", "计算CS分数", "计算Q = 10的评分贡献分数", "通过在calculate_final_score方法中使用两个分数来计算最终分数", "获得得分最高的前5个城市，并以JSON格式返回"]
}, {
  "tag": "H2",
  "text": "Request",
  "translation": "请求"
}, {
  "tag": "P",
  "text": "Now that we have our method, we can make requests to get recommendations. First lets open request.py file and add a method to retrieve recommendations from RecommenderEngine class:",
  "translation": "现在有了我们的方法，我们可以请求获取建议。 首先让我们打开request.py文件，并添加一个方法来从RecommenderEngine类中检索建议："
}, {
  "tag": "PRE",
  "text": "def get_recommendations_include_rating(keywords):    return RecommenderEngine.get_recommendations_include_rating(keywords)",
  "translation": "def get_recommendations_include_rating（keywords）：返回RecommenderEngine.get_recommendations_include_rating（keywords）"
}, {
  "tag": "P",
  "text": "Now let’s add new requests to get recommendations for 3 categories with the new method.",
  "translation": "现在，我们添加新请求，以使用新方法获取3个类别的推荐。"
}, {
  "tag": "PRE",
  "text": "# Version 2 requests are below:top_5_cultural_with_rating = get_recommendations_include_rating(culture_keywords)city_names_for_cultural_rating = get_top_5_city_names_out_of_json(top_5_cultural_with_rating)print(city_names_for_cultural_rating)print(\"#################\")top_5_summer_with_rating = get_recommendations_include_rating(beach_n_sun_keywords)city_names_for_summer_rating = get_top_5_city_names_out_of_json(top_5_summer_with_rating)print(city_names_for_summer_rating)print(\"#################\")top_5_party_with_rating = get_recommendations_include_rating(nightlife_keywords)city_names_for_party_rating = get_top_5_city_names_out_of_json(top_5_party_with_rating)print(city_names_for_party_rating)print(\"#################\")",
  "translation": "＃版本2请求如下：top_5_cultural_with_rating = get_recommendations_include_rating（culture_keywords）city_names_for_cultural_rating = get_top_5_city_names_out_of_json（top_5_cultural_with_rating）print（city_names_for_cultural_rating）print（############################# _＃）city_names_for_summer_rating= get_top_5_city_names_out_of_json（top_5_summer_with_rating）打印（city_names_for_summer_rating）打印（ “#################”）top_5_party_with_rating= get_recommendations_include_rating（nightlife_keywords）city_names_for_party_rating= get_top_5_city_names_out_of_json（top_5_party_with_rating）打印（city_names_for_party_rating）打印 （“ #################”）"
}, {
  "tag": "P",
  "text": "The code above will fetch recommendations with their final score, you can run it and see the results you get.",
  "translation": "上面的代码将获取建议及其最终分数，您可以运行它并查看获得的结果。"
}, {
  "tag": "P",
  "text": "We will only investigate the results for Culture, art and history in this article for two different perspective. First we will compare the results we get with the only CS score method which was implemented in the first version and the results we get with the new method we just implemented.",
  "translation": "在本文中，我们仅从两个不同的角度调查文化，艺术和历史的结果。 首先，我们将比较在第一个版本中实施的唯一CS评分方法获得的结果与在刚刚实施的新方法中获得的结果。"
}, {
  "tag": "H2",
  "text": "Comparison of get_recommendations and get_recommendations_include_rating methods:",
  "translation": "get_recommendations和get_recommendations_include_rating方法的比较："
}, {
  "tag": "P",
  "text": "The following code is for experimental purposes so they are not included again in request.py, as both these requests already exist.",
  "translation": "以下代码用于实验目的，因此它们不再存在于request.py中，因为这两个请求均已存在。"
}, {
  "tag": "PRE",
  "text": "top_5_cultural_cities = get_recommendations(culture_keywords)city_names_for_cultural = get_top_5_city_names_out_of_json(top_5_cultural_cities)print(city_names_for_cultural)print(\"#################\")top_5_cultural_with_rating = get_recommendations_include_rating(culture_keywords)city_names_for_cultural_rating = get_top_5_city_names_out_of_json(top_5_cultural_with_rating)print(city_names_for_cultural_rating)print(\"#################\")",
  "translation": "top_5_cultural_cities= get_recommendations（culture_keywords）city_names_for_cultural= get_top_5_city_names_out_of_json（top_5_cultural_cities）打印（city_names_for_cultural）打印（ “#################”）top_5_cultural_with_rating= get_recommendations_include_rating（culture_keywords）city_names_for_cultural_rating= get_top_5_city_names_out_of_json（top_5_cultural_with_rating） 列印（city_names_for_cultural_rating）列印（“ ##################”）"
}, {
  "tag": "P",
  "text": "Here we observe the output of two different methods:",
  "translation": "在这里，我们观察两种不同方法的输出："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.21629522817435007), ('St. Petersburg', 0.16666666666666666), ('Stockholm', 0.14962640041614492), ('Milan', 0.140028008402801), ('Rome', 0.12171612389003691)]#################[('Athens', 0.22927294186481106), ('Stockholm', 0.1556114564327907), ('St. Petersburg', 0.15333333333333332), ('Milan', 0.15123024907502508), ('Rome', 0.13145341380123987)]",
  "translation": "[（'雅典'，0.21629522817435007），（'圣彼得堡'，0.16666666666666666），（'斯德哥尔摩'，0.14962640041614492），（'米兰'，0.140028008402801），（'罗马'，0.12171612389003691）] ####### ######### [（'雅典'，0.22927294186481106，（'斯德哥尔摩'，0.1556114564327907），（'圣彼得堡'，0.15333333333333332），（'米兰'，0.15123024907502508），（'罗马'， 0.13145341380123987）]"
}, {
  "tag": "P",
  "text": "Here we have different scores for two methods and you can see that when rating is taken into account, Stockholm rises to second place while St. Petersburg falls to third. Lets see why:",
  "translation": "在这里，我们对两种方法的评分不同，您可以看到，如果考虑到评分，斯德哥尔摩将升至第二位，而圣彼得堡则降至第三位。 让我们看看为什么："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*u_LeOF5R1e6twz_DGb-UTA.png?q=20",
  "type": "image",
  "file": "1*u_LeOF5R1e6twz_DGb-UTA.png"
}, {
  "tag": "P",
  "text": "As you can see in our dataset, Stockholm has a rating of 7 while St. Petersburg has 1. Then our algorithm lowers the final scores for St. Petersburg and increases it for Stockholm as mentioned earlier, which results in Stockholm rising to second place. Here we can see that with the implemented methods and formulas, our recommender system encourages content with good ratings while discouraging the ones with bad ratings. You can also observe the dataset for other cities rankings to see why their final score is increased in comparison to only cosine similarity score.",
  "translation": "正如您在数据集中看到的那样，斯德哥尔摩的评分为7，而圣彼得堡的评分为1。然后我们的算法降低了圣彼得堡的最终得分，并提高了斯德哥尔摩的最终得分，如前所述，这使斯德哥尔摩升至第二位。 在这里，我们可以看到，通过实施的方法和公式，我们的推荐系统可以鼓励收视率较高的内容，而劝阻收视率较低的内容。 您还可以观察其他城市排名的数据集，以了解为什么最终得分比仅余弦相似性得分有所提高。"
}, {
  "tag": "H2",
  "text": "Comparison of get_recommendations_include_rating method with Q = 10 and Q = 100:",
  "translation": "Q = 10和Q = 100的get_recommendations_include_rating方法的比较："
}, {
  "tag": "P",
  "text": "Now we will compare our new method with different Q parameters. Lower Q means less rating contribution to final score and higher Q means higher contribution. As we printed out earlier, the following is the recommendations we get for Culture, Art and History category with Q = 10:",
  "translation": "现在，我们将比较具有不同Q参数的新方法。 较低的Q表示对最终分数的评分贡献较小，而较高的Q表示较高的贡献。 正如我们之前打印的那样，以下是针对Q = 10的文化，艺术和历史类别的建议："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.22927294186481106), ('Stockholm', 0.1556114564327907), ('St. Petersburg', 0.15333333333333332), ('Milan', 0.15123024907502508), ('Rome', 0.13145341380123987)]",
  "translation": "[（'雅典'，0.22927294186481106，（'斯德哥尔摩'，0.1556114564327907），（'圣彼得堡'，0.15333333333333332），（'米兰'，0.15123024907502508），（'罗马'，0.13145341380123987）]"
}, {
  "tag": "P",
  "text": "You can go to recommender_engine.py and, replace 10 with 100 to increase Q parameter in get_recommendations_include_rating method:",
  "translation": "您可以转到Recommendationer_engine.py并将10替换为100以增加get_recommendations_include_rating方法中的Q参数："
}, {
  "tag": "PRE",
  "text": "rating_contribution = RatingExtractor.get_rating_weight(rating,100)",
  "translation": "rating_contribution = RatingExtractor.get_rating_weight（rating，100）"
}, {
  "tag": "P",
  "text": "Now lets see how the results change:",
  "translation": "现在让我们看看结果如何变化："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.3460723650789601), ('Milan', 0.2520504151250418), ('Rome', 0.21908902300206645), ('Stockholm', 0.2094769605826029), ('Venice', 0.17777777777777776)]",
  "translation": "[（'雅典'，0.3460723650789601），（'米兰'，0.2520504151250418），（'罗马'，0.21908902300206645）（（'斯德哥尔摩'，0.2094769605826029），（'威尼斯'，0.17777777777777776）]]"
}, {
  "tag": "P",
  "text": "We can observe that our results are very different now.",
  "translation": "我们可以观察到我们的结果现在非常不同。"
}, {
  "tag": "UL",
  "texts": ["St. Petersburg is not in the top 5 anymore as it has rating of 1, with higher Q the city is highly discouraged for recommendation", "Milan and Rome rose to second and third place respectively while Stockholm fell down to fourth, since Milan and Rome have higher ratings than Stockholm."],
  "translations": ["圣彼得堡不再是前5名，因为它的排名为1，Q值较高，因此强烈不建议该城市", "米兰和罗马分别上升到第二和第三位，而斯德哥尔摩下降到第四位，因为米兰和罗马的评级高于斯德哥尔摩。"]
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*L6b7lPX8dTSpAkfAzOZ0BA.png?q=20",
  "caption": "Rating comparison for Stockholm, Rome and Milan",
  "type": "image",
  "file": "1*L6b7lPX8dTSpAkfAzOZ0BA.png"
}, {
  "tag": "P",
  "text": "I recommend you to check results for other categories and how they change with different Q values as well.",
  "translation": "我建议您检查其他类别的结果，以及它们如何随着不同的Q值而变化。"
}, {
  "tag": "H2",
  "text": "Conclusion for Version-2",
  "translation": "版本2的结论"
}, {
  "tag": "P",
  "text": "In Version-2 we have implemented a method to recommend cities by calculating a final score from Cosine Similarity score based on description feature and rating contribution score based on rating feature. It is important to make use of information such as rating, since in recommender systems we often want to recommend good content to the users.",
  "translation": "在版本2中，我们实施了一种方法，通过根据描述特征基于余弦相似度得分和基于评级特征的评级贡献得分计算最终得分来推荐城市。 利用评级等信息非常重要，因为在推荐系统中，我们经常希望向用户推荐优质内容。"
}, {
  "tag": "P",
  "text": "You can access all the code written for second version here.",
  "translation": "您可以在此处访问为第二版本编写的所有代码。"
}, {
  "tag": "P",
  "text": "In the next version below, we will implement another method to improve our recommender application by using rating count feature in the dataset.",
  "translation": "在下面的下一版本中，我们将通过使用数据集中的评分计数功能来实现另一种方法来改进推荐程序。"
}, {
  "tag": "H1",
  "text": "Version-3 (Rating thresholding)",
  "translation": "版本3（评分阈值）"
}, {
  "tag": "P",
  "text": "Just because a content has good rating, does not mean that the rating is reliable. Imagine we have two contents A and B, A has average rating of 4.7 from 500.000 users and B has rating of 5 from only 10 users. Which one would you like to recommend to a friend of yours? How reliable do you think B can be with only 10 users provided rating? With the help of rating_count feature, we will come up with a threshold parameter so our recommender system will be able to cope with content (cities in our case) with low rating count as not putting much importance on rating contribution.",
  "translation": "仅因为内容具有良好的评分，并不表示该评分是可靠的。 想象一下，我们有两个内容A和B，A的500.000个用户的平均评分为4.7，B的仅10个用户的评分为5。 您想向您的朋友推荐哪一个？ 您认为仅提供10个用户的评分，B的可靠性如何？ 借助rating_count功能，我们将提出一个阈值参数，因此我们的推荐系统将能够处理评级计数较低的内容（在我们的情况下为城市），因为对评级贡献的重视程度不高。"
}, {
  "tag": "H2",
  "text": "Rating weight generation with rating and count features",
  "translation": "具有评级和计数功能的评级权重生成"
}, {
  "tag": "P",
  "text": "In this version, we will develop a couple of new methods to improve our recommender system so that it will have a threshold value for rating contribution calculation. Now I will introduce you a formula that I came up with during my thesis:",
  "translation": "在此版本中，我们将开发一些新方法来改进推荐系统，使其具有用于评分贡献计算的阈值。 现在，我将向您介绍我在论文中提出的公式："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*IwRNiI8ZFZdmkaJGSXrk7A.png?q=20",
  "caption": "Multiplier formula",
  "type": "image",
  "file": "1*IwRNiI8ZFZdmkaJGSXrk7A.png"
}, {
  "tag": "P",
  "text": "This formula results in M which is the multiplier value which will be multiplied with the rating contribution value we get, before using it for final recommendation score calculation. Here T represents the threshold value and c represents the rating count. This formula constructed in a way that it has the following properties:",
  "translation": "此公式的结果为M，该乘数将乘以我们获得的评分贡献值，然后再用于最终推荐分数计算。 在此，T表示阈值，c表示额定值。 具有以下属性的方式构造的此公式："
}, {
  "tag": "UL",
  "texts": ["The range of the output is between 0.0 and 1.0", "If T and c parameters are equal to each other, the formula always yields 0.5"],
  "translations": ["输出范围在0.0到1.0之间", "如果T和c参数彼此相等，则公式始终得出0.5"]
}, {
  "tag": "P",
  "text": "There is nothing special with number e for this formula though, it could be any number (then 0,68 had to change as well). I just used e to make it look cool :P",
  "translation": "尽管此公式的数字e没有什么特别的，它可以是任何数字（然后，0.68也必须更改）。 我只是用e使其看起来很酷：P"
}, {
  "tag": "P",
  "text": "So the main importance of the method is that, it yields 0.50 when T = c. This is how the thresholding is going to work. We will set a threshold value T for rating count so that if rating count is less than threshold, the output will be in the range of 0.0–0.50 (depending how low.) and if rating count is greater than threshold, the output will be between 0.50 and 1.0 but can never exceed 1.0.",
  "translation": "因此，该方法的主要重要性在于，当T = c时，它的值为0.50。 阈值就是这样工作的。 我们将为等级计数设置阈值T，以便如果等级计数小于阈值，则输出将在0.0–0.50范围内（取决于低值）。如果等级计数大于阈值，则输出将为0.0-5。 介于0.50和1.0之间，但不能超过1.0。"
}, {
  "tag": "P",
  "text": "As mentioned this multiplier will be applied to the rating contribution value only so we will not care much about the rating where there aren’t significant amount of ratings provided and the output will lower the rating contribution. Thus, the recommendation will mainly fall into CS score. But if a place has more ratings, then the rating contribution value will be high as well and overall final recommendation score will be higher.",
  "translation": "如前所述，此乘数仅应用于评分贡献值，因此我们不会在没有提供大量评分的情况下关注评分，而输出会降低评分贡献。 因此，推荐将主要落入CS得分。 但是，如果某个地方的评分较高，那么评分贡献值也将很高，最终总推荐分数也会更高。"
}, {
  "tag": "P",
  "text": "Now let’s go to rating_extractor.py file and create a new method. We will just multiply the rating contribution value with the multiplier, but let’s create a new method so you can still have other approach and use it as it is.",
  "translation": "现在，我们转到rating_extractor.py文件并创建一个新方法。 我们将乘以乘数作为评分贡献值，但让我们创建一个新方法，以便您仍然可以使用其他方法并按原样使用它。"
}, {
  "tag": "P",
  "text": "First we need to import e from math:",
  "translation": "首先，我们需要从数学中导入e："
}, {
  "tag": "PRE",
  "text": "from math import e",
  "translation": "从数学导入e"
}, {
  "tag": "P",
  "text": "Then in RatingExtractor class, add the new method:",
  "translation": "然后在RatingExtractor类中，添加新方法："
}, {
  "tag": "PRE",
  "text": "@staticmethoddef get_rating_weight_with_quantity(rating, c, T, q=10):    if rating > 10 or rating < 0:        return None    else:        m = (2*q) / 10 #10 because rating varies between 0 and 10        b = -q        val = (m*rating) + b        M = e**((-T*0.68)/c)        return val * M",
  "translation": "@staticmethoddef get_rating_weight_with_quantity（rating，c，T，q = 10）：如果等级> 10或等级<0：返回其他：m =（2 * q）/ 10＃10，因为等级在0到10之间变化b = -q val =（m *额定值）+ b M = e **（（-T * 0.68）/ c）返回val * M"
}, {
  "tag": "P",
  "text": "Method works as following:",
  "translation": "方法如下："
}, {
  "tag": "UL",
  "texts": ["It takes rating, c (rating_count), T (threshold) and q parameters.", "We already know rating and q paremeters from the previous chapter.", "c refers to the amount of users provided rating", "T refers to the threshold value introduced above", "Calculates the rating contribution value", "Calculates the multiplier M value", "Returns the rating weight by multiplying contribution with M"],
  "translations": ["它使用等级，c（等级计数），T（阈值）和q参数。", "我们已经从上一章知道了等级和q参数。", "c指用户提供的评级数量", "T是指上面介绍的阈值", "计算评分贡献值", "计算乘数M值", "通过将贡献乘以M返回评分权重"]
}, {
  "tag": "H2",
  "text": "Implementing a new method in Recommender Engine",
  "translation": "在推荐引擎中实现新方法"
}, {
  "tag": "P",
  "text": "Let’s open recommender_engine.py and add a new method to RecommenderEngine class (we will keep the methods we have implemented in previous versions) It is actually almost exactly the same as the method we added to RecommenderEngine in previous chapter, but this time we will pass rating count and a threshold value along with city description and rating features:",
  "translation": "让我们打开Recommendationer_engine.py并向RecommenderEngine类添加一个新方法（我们将保留在先前版本中实现的方法）它实际上与我们在上一章中添加到RecommenderEngine的方法几乎完全相同，但是这次我们将通过 评分计数和阈值以及城市描述和评分功能："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/ec5606f4d7894c4eab8a64abc5ec80c8/raw/1d8e8cbc5e6180fa1dec22f4aa0101fb98684f06/recommender_engine_version3_method.py",
  "code": "# Version-3\n    def get_recommendations_include_rating_count_threshold(keywords):\n        df = pd.read_csv('city_data_cleared.csv')\n\n        score_dict = {}\n\n        for index, row in df.iterrows():\n            cs_score = CosineSimilarity.cosine_similarity_of(row['description'], keywords)\n\n            rating = row['rating']\n            rating_count = row['rating_count']\n            threshold = 1000000\n            rating_contribution = RatingExtractor.get_rating_weight_with_quantity(rating,rating_count,threshold,10)\n\n            final_score = RecommenderEngine.calculate_final_score(cs_score, rating_contribution)\n\n            score_dict[index] = final_score\n\n        #sort cities by score and index.\n        sorted_scores = sorted(score_dict.items(), key=operator.itemgetter(1), reverse=True)\n\n        counter = 0\n\n        #create an empty results data frame.\n        resultDF = pd.DataFrame(columns=('city', 'popularity', 'description', 'score'))\n\n        #get highest scored 5 cities.\n        for i in sorted_scores:\n            #print index and score of the city.\n            #print(i[0], i[1])\n            resultDF = resultDF.append({'city': df.iloc[i[0]]['city'], 'popularity': df.iloc[i[0]]['popularity'], 'description': df.iloc[i[0]]['description'], 'score': i[1]}, ignore_index=True)\n            counter += 1\n\n            if counter>4:\n                break\n\n        #convert DF to json.\n        json_result = json.dumps(resultDF.to_dict('records'))\n        return json_result"
}, {
  "tag": "P",
  "text": "The method works as the following:",
  "translation": "该方法的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["Takes keywords parameter and does the following for every city in the dataset", "Computes CS score", "Gets a rating contribution weight by passing rating of the city, rating count, threshold value as 1 million (The cities in the dataset have rating count between 100k and 5M, I’ve selected 1 million initially but we will play around with this) and Q=10", "Computes final score with calculate_final_score method (implemented in previous chapter) by using CS score and the rating weight.", "Gets top 5 cities with highest final score and returns as JSON"],
  "translations": ["获取关键字参数，并对数据集中的每个城市执行以下操作", "计算CS分数", "通过将城市的等级，等级数，阈值传递为100万来获得等级贡献权重（数据集中的城市的等级数在100k和5M之间，我最初选择了100万，但我们将继续使用它） Q = 10", "通过使用CS分数和等级权重，使用calculate_final_score方法（在上一章中实现）计算最终分数。", "获得得分最高的前5个城市，并以JSON格式返回"]
}, {
  "tag": "H2",
  "text": "Request",
  "translation": "请求"
}, {
  "tag": "P",
  "text": "We will add new requests to the request.py file to get recommendations for 3 categories with the new method",
  "translation": "我们将向request.py文件添加新请求，以使用新方法获取3个类别的建议"
}, {
  "tag": "P",
  "text": "First lets add a method to retrieve recommendations with new implementation from RecommenderEngine class:",
  "translation": "首先，让我们添加一个方法，以从RecommenderEngine类中以新的实现检索建议："
}, {
  "tag": "PRE",
  "text": "def get_recommendations_include_rating_count_threshold(keywords):    return RecommenderEngine.get_recommendations_include_rating_count_threshold(keywords)",
  "translation": "def get_recommendations_include_rating_count_threshold（关键字）：返回RecommenderEngine.get_recommendations_include_rating_count_threshold（关键字）"
}, {
  "tag": "P",
  "text": "Now let’s add new requests to get recommendations for 3 categories with the new method.",
  "translation": "现在，我们添加新请求，以使用新方法获取3个类别的推荐。"
}, {
  "tag": "PRE",
  "text": "# Version 3 requests are below:top_5_cultural_with_rating_count_threshold = get_recommendations_include_rating_count_threshold(culture_keywords)city_names_for_cultural_rating_count_threshold = get_top_5_city_names_out_of_json(top_5_cultural_with_rating_count_threshold)print(city_names_for_cultural_rating_count_threshold)print(\"#################\")top_5_summer_with_rating_count_threshold = get_recommendations_include_rating_count_threshold(beach_n_sun_keywords)city_names_for_summer_rating_count_threshold = get_top_5_city_names_out_of_json(top_5_summer_with_rating_count_threshold)print(city_names_for_summer_rating_count_threshold)print(\"#################\")top_5_party_with_rating_count_threshold = get_recommendations_include_rating_count_threshold(nightlife_keywords)city_names_for_party_rating_count_threshold = get_top_5_city_names_out_of_json(top_5_party_with_rating_count_threshold)print(city_names_for_party_rating_count_threshold)print(\"#################\")",
  "translation": "＃3版请求是以下：top_5_cultural_with_rating_count_threshold= get_recommendations_include_rating_count_threshold（culture_keywords）city_names_for_cultural_rating_count_threshold= get_top_5_city_names_out_of_json（top_5_cultural_with_rating_count_threshold）打印（city_names_for_cultural_rating_count_threshold）打印（ “#################”）top_5_summer_with_rating_count_threshold= get_recommendations_include_rating_count_threshold（beach_n_sun_keywords）city_names_for_summer_rating_count_threshold= get_top_5_city_names_out_of_json（top_5_summer_with_rating_count_threshold）打印（city_names_for_summer_rating_count_threshold）打印（ “#################”）top_5_party_with_rating_count_threshold= get_recommendations_include_rating_count_threshold（nightlife_keywords）city_names_for_party_rating_count_threshold= get_top_5_city_names_out_of_json（top_5_party_with_rating_count_threshold）打印（city_names_for_party_rating_count_threshold）打印 （“ ##################”）"
}, {
  "tag": "P",
  "text": "The code above will fetch recommendations with their final score, you can run it and see the results you get for all the categories. But we will only investigate the results for Culture, Art and History category.",
  "translation": "上面的代码将获取建议及其最终分数，您可以运行它并查看所有类别的结果。 但是，我们只会调查“文化，艺术和历史”类别的结果。"
}, {
  "tag": "H2",
  "text": "Comparison of the results with different threshold values",
  "translation": "比较具有不同阈值的结果"
}, {
  "tag": "P",
  "text": "Lets make experimental requests with different threshold (T) values for Culture, Art and History category. You can change threshold in get_recommendations_include_rating_count_threshold method of RecommenderEngine class. Also this time lets change Q parameter (rating contribution importance parameter introduced in the previous chapter) to 100 so we can see the threshold effect better.",
  "translation": "让我们针对“文化，艺术和历史”类别提出具有不同阈值（T）的实验性请求。 您可以在RecommenderEngine类的get_recommendations_include_rating_count_threshold方法中更改阈值。 这次也将Q参数（在上一章中介绍的评级贡献重要性参数）更改为100，以便更好地看到阈值效果。"
}, {
  "tag": "P",
  "text": "Results for threshold = 100.000:",
  "translation": "阈值= 100.000的结果："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.33318171469723395), ('Milan', 0.24587898720843948), ('Rome', 0.21192640793273687), ('Stockholm', 0.18358642633975064), ('Venice', 0.17262307588744202)]",
  "translation": "[（'Athens'，0.33318171469723395），（'Milan'，0.24587898720843948），（'Rome'，0.21192640793273687），（'Stockholm'，0.18358642633975064），（'Venice'，0.17262307588744202）]]"
}, {
  "tag": "P",
  "text": "Results for threshold = 1.000.000:",
  "translation": "阈值= 1.000.000的结果："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.26188415260156817), ('Milan', 0.2035910531885378), ('Rome', 0.16707033294390228), ('Stockholm', 0.14983344608755947), ('Barcelona', 0.14757848986361075)]",
  "translation": "[（'雅典'，0.26188415260156817），（'米兰'，0.2035910531885378），（'罗马'，0.16707033294390228），（'斯德哥尔摩'，0.14983344608755947），（'巴塞罗那'，0.14757848986361075）]"
}, {
  "tag": "P",
  "text": "Results for threshold = 2.500.000:",
  "translation": "阈值= 2.500.000的结果："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.2257870828894539), ('Milan', 0.16719580286435054), ('St. Petersburg', 0.158824470447676), ('Stockholm', 0.14962644254339), ('Rome', 0.13613352041126298)]",
  "translation": "[（'雅典'，0.2257870828894539，（'米兰'，0.16719580286435054），（'圣彼得堡'，0.158824470447676），（'斯德哥尔摩'，0.14962644254339），（'罗马'，0.13613352041126298）]"
}, {
  "tag": "P",
  "text": "As you can see for the threshold 100K and 1M; the 5th place is different, when the threshold value is lower, we have Venice in the 5th place and we have Barcelona when the value is higher. Lets see why:",
  "translation": "如您所见，阈值为100K和1M； 第五名是不同的，当阈值较低时，我们在第五名中有威尼斯，而在阈值较高时，我们是巴塞罗那。 让我们看看为什么："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*z-Q5cyg0v6v__mElMDAC0w.png?q=20",
  "caption": "Rating and Rating count for Barcelona and Venice",
  "type": "image",
  "file": "1*z-Q5cyg0v6v__mElMDAC0w.png"
}, {
  "tag": "P",
  "text": "They both have rating of 8 but Barcelona has 1.200.000 ratings while Venice has 845.000, and also Venice has more CS score than Barcelona. So when threshold is 100.000, both cities can provide good amount of rating contribution and since Venice has higher CS score, we see it in the 5th place.",
  "translation": "他们俩的评分均为8，但巴塞罗那的评分为120万，而威尼斯的评分为845.000，威尼斯的CS评分也比巴塞罗那高。 因此，当阈值为100.000时，两个城市都可以提供大量的评分贡献，并且由于威尼斯的CS评分较高，我们将其排名为第五。"
}, {
  "tag": "P",
  "text": "But when the threshold is 1.000.000, then the contribution score are following(Q=100):",
  "translation": "但是当阈值为1.000.000时，贡献分数如下（Q = 100）："
}, {
  "tag": "UL",
  "texts": ["Barcelona: 34", "Venice: 26.8"],
  "translations": ["巴塞罗那：34", "威尼斯：26.8"]
}, {
  "tag": "P",
  "text": "As Barcelona has higher output now and since Q is also high, the final score calculation for Barcelona will be greater than Venice and thus Barcelona is on the 5th place.",
  "translation": "由于巴塞罗那现在的产出更高，并且Q也很高，因此巴塞罗那的最终得分计算将大于威尼斯，因此巴塞罗那排名第五。"
}, {
  "tag": "P",
  "text": "When the threshold value is 2.500.000, you can see that we have St. Petersburg on 3rd place, whilst we didn’t even have it on fourth or fifth place when threshold value was lower. I will leave the investigation of that to you. Check the dataset for St. Petersburg, go through how our implementations work and see if you can understand why we have St. Petersburg for higher thresholds. Let me know if you have any questions on the comments :)",
  "translation": "当阈值为2.500.000时，您会看到我们在第三名的位置上是圣彼得堡，而当阈值较低时，我们甚至没有在第四或第五位上。 我将对此进行调查。 查看圣彼得堡的数据集，查看我们的实现工作原理，看看您是否能理解为什么我们在圣彼得堡设置了更高的阈值。 如果您对评论有任何疑问，请告诉我：)"
}, {
  "tag": "P",
  "text": "I furthermore encourage you to play around with all these parameters, check features for the dataset (it should be fine as we have only 25 cities) and try to understand how these methods can be effective for recommender systems.",
  "translation": "此外，我鼓励您使用所有这些参数，检查数据集的功能（这应该很好，因为我们只有25个城市），并尝试了解这些方法如何对推荐系统有效。"
}, {
  "tag": "H2",
  "text": "Conclusion for Version-3",
  "translation": "版本3的结论"
}, {
  "tag": "P",
  "text": "In Version-3 we have implemented a method to recommend cities by first calculating the Cosine Similarity score, calculating a rating weight output by using both rating and rating count features and then calculating a final score with both results. It is important to use reliable information so with these implementations we have seen how we can improve our recommender system such that it could rely more on the content with higher (highness depends on the context of the application) feedback.",
  "translation": "在版本3中，我们实施了一种推荐城市的方法，首先计算余弦相似度得分，使用评级和评级计数功能计算评级权重输出，然后使用两个结果计算最终得分。 使用可靠的信息非常重要，因此通过这些实现，我们已经看到了如何改进推荐系统，以便它可以更多地依赖具有较高反馈（高度取决于应用程序上下文）的内容。"
}, {
  "tag": "P",
  "text": "You can access all the code written for third version here.",
  "translation": "您可以在此处访问为第三个版本编写的所有代码。"
}, {
  "tag": "P",
  "text": "In the next version below, we will improve our recommender system even further by investigating how to make use of feedback in different forms.",
  "translation": "在下面的下一个版本中，我们将通过研究如何利用不同形式的反馈来进一步改进推荐系统。"
}, {
  "tag": "H1",
  "text": "Version-4",
  "translation": "版本4"
}, {
  "tag": "P",
  "text": "In this version we will improve our system further as the fourth version by using positive_review and negative_review features of our dataset.",
  "translation": "在此版本中，我们将通过使用数据集的positive_review和negative_review功能进一步改进我们的系统作为第四版。"
}, {
  "tag": "P",
  "text": "This chapter is going to focus on the theory and the experimental results (not executed hands on here but rather on a results table) of the approach more than previous chapters, so if you are just interested with the code implementation, you can directly go to Implementation section.",
  "translation": "本章将比前几章更多地关注该方法的理论和实验结果（不是在此处执行而是在结果表上），因此，如果您仅对代码实现感兴趣，则可以直接转到 实施部分。"
}, {
  "tag": "P",
  "text": "Sometimes, we might have different types of feedback available for our content. Such as reviews and ratings. As you can guess, they are not exactly the same kind of feedback, rating feedback is provided on a given scale (0–10 for our case) and review is usually given in the text format. Lets say we have classified the reviews as positive and negative feedback (maybe we can investigate review classification on another article) then the review feedback could be analyzed as binary feedback (0 or 1); meaning, negative or positive review.",
  "translation": "有时，我们可能对我们的内容有不同类型的反馈。 例如评论和评分。 您可能会猜到，它们并不是完全相同的反馈，以给定的比例（在我们的案例中为0-10）提供了评分反馈，而评论通常以文本格式给出。 假设我们将评论分为正面和负面反馈（也许我们可以研究另一篇文章的评论分类），然后可以将评论反馈分析为二进制反馈（0或1）； 表示正面或负面评价。"
}, {
  "tag": "P",
  "text": "We already have two features positive_review and negative_review available in our dataset. These features represent the count of positive and negative reviews a city received.",
  "translation": "我们的数据集中已有两个功能positive_review和negative_review。 这些功能代表了城市收到的正面和负面评论的数量。"
}, {
  "tag": "P",
  "text": "One of the challenges of recommender systems is incorporating feedback in different forms. There could be many different ways of doing it, in this chapter we will try to make use of both feedback forms by converting reviews into rating form with a custom approach.",
  "translation": "推荐系统的挑战之一是采用不同形式的反馈。 这样做的方式可能有很多，在本章中，我们将尝试通过使用自定义方法将评论转换为评分形式来利用两种反馈形式。"
}, {
  "tag": "H2",
  "text": "Converting reviews to rating scale",
  "translation": "将评论转换为评分等级"
}, {
  "tag": "P",
  "text": "A basic approach of doing so would be to select two rating values for both negative and positive feedback, and then consider each review feedback as a rating and recalculate the average rating of an item. But this approach would not be ideal. For example, if the ratings are selected as 0 and 10 for negative and positive reviews, then the effect of reviews would be more than actual rating data especially when the rating of an item is either closer to 0 or 10. It could be possible to select different rating values to alleviate the review effect on the rating. For example, if the ratings are selected as 2.5 and 7.5, then another problem would occur where a positive feedback for an item with average rating greater than 7.5 would still contribute as lowering the rating, whereas a negative feedback for an item with average rating less than 2.5 would contribute as increasing the rating. Hence, another approach is needed in order to incorporate both forms better.",
  "translation": "这样做的基本方法是为负面和正面反馈选择两个评分值，然后将每个评论反馈视为评分，然后重新计算商品的平均评分。 但是这种方法并不理想。 例如，如果将负面评论和正面评论的评分分别选择为0和10，则评论的效果将超过实际评分数据，尤其是当某项的评分接近0或10时。 选择不同的评分值以减轻审核对评分的影响。 例如，如果将评级分别选择为2.5和7.5，则会出现另一个问题，即平均评级大于7.5的项目的正反馈仍会降低评级，而平均评级小于此值的项目的负反馈 超过2.5会增加评分。 因此，需要另一种方法以便更好地结合两种形式。"
}, {
  "tag": "P",
  "text": "Our approach will be behaving like the following for both positive and negative reviews accordingly:",
  "translation": "对于正面评价和负面评价，我们的方法都将如下所示："
}, {
  "tag": "UL",
  "texts": ["For any positive review, a new rating value is added to the ratings by calculating the distance between the average rating of the item and maximum rating value (10 in our case) and then adding half of the calculated distance to the average rating to determine rating value for review.", "For any negative review, a new rating value is added to the ratings by calculating the distance between the average rating of the item and minimum rating value (0 in our case) and then subtracting half of the calculated distance from the average rating to determine rating value for review."],
  "translations": ["对于任何正面评价，通过计算商品的平均评分与最大评分值之间的距离（在本例中为10），然后将计算所得距离的一半加到平均评分中，以确定评分，从而将新的评分值添加到评分中 审查价值。", "对于任何负面评论，通过计算商品的平均评分与最小评分值之间的距离（在我们的示例中为0），然后从平均评分中减去所计算距离的一半来确定评分，从而将新的评分值添加到评分中 审查价值。"]
}, {
  "tag": "P",
  "text": "Formulas for converting both positive and negative reviews to rating values, Rp and Rn respectively for a given item with average rating of r are given below:",
  "translation": "下面给出了将给定项目的平均评价为r的正面和负面评论分别转换为评级值Rp和Rn的公式："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*avtIfugLIW6_CwJxOyPlLg.png?q=20",
  "caption": "Rating value conversion for a positive review",
  "type": "image",
  "file": "1*avtIfugLIW6_CwJxOyPlLg.png"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*b_RnbZsY0gYa-fulKfg39g.png?q=20",
  "caption": "Rating value conversion for a negative review",
  "type": "image",
  "file": "1*b_RnbZsY0gYa-fulKfg39g.png"
}, {
  "tag": "P",
  "text": "For instance, for an item with average rating of 6 (range 0–10), for every negative review, a new rating with value of 3 is added to ratings, whereas for every positive review, a new rating with value of 8 is added to ratings. Then the average rating is calculated again with new ratings before fed into the scoring function. Review feedback conversion into rating feedback results are shown in the table below for different ratings, rating counts and review counts.",
  "translation": "例如，对于平均评分为6（范围为0–10）的项目，对于每个负面评论，将新值为3的评分添加到评分中，而对于每个正面评论，则添加为8的新评分 评级。 然后，在输入评分功能之前，用新的评分再次计算平均评分。 下表显示了针对不同评分，评分计数和评论计数的审阅反馈转换为评分反馈结果。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*thRMbk5DHyloHa6e0uYOGw.png?q=20",
  "caption": "Rating calculation results with average rating and reviews",
  "type": "image",
  "file": "1*thRMbk5DHyloHa6e0uYOGw.png"
}, {
  "tag": "P",
  "text": "Final rating results suggest that with the current implementation, when rating value gets closer to either maximum or minimum value, calculated rating tends to favour the opposite rating value. For example, for the case where rating is 7,2 and positive and negative review counts are equal, the result is 6,65 as it goes closer to minimum rating from the original value. This is because, the distance between 0 and 7,2, is greater than the distance between 7,2 and 10, similar behaviour is also observed when the original rating is 2,8 with equal positive and negative rating values as well. Moreover, the effect of the reviews is minimal since the test cases included more rating values than review which is often case for the commercial recommender systems. The effect could have been increased by introducing an additional parameter to change the importance of reviews to make this approach more efficient (For example for every review, we could generate 10 rating values with the calculated value).",
  "translation": "最终评级结果表明，在当前实施方案中，当评级值越来越接近最大值或最小值时，计算得出的评级往往倾向于相反的评级值。例如，对于评分为7.2，正面和负面评论计数相等的情况，结果是从原始值接近最小评分时为6.65。这是因为0和7,2之间的距离大于7,2和10之间的距离，当原始额定值为2,8时，也具有相同的正负额定值，也会观察到类似的行为。此外，评论的影响很小，因为测试案例包含的评分值比评论多，这在商业推荐系统中通常是这样。可以通过引入其他参数来更改评论的重要性以提高此方法的效率，从而提高效果（例如，对于每个评论，我们可以使用计算出的值生成10个评分值）。"
}, {
  "tag": "H2",
  "text": "Implementation",
  "translation": "实作"
}, {
  "tag": "P",
  "text": "Now we have investigated the way it works and results it can generate, lets go ahead and implement a new method in RatingExtractor class:",
  "translation": "现在，我们研究了它的工作方式以及它可以生成的结果，让我们继续并在RatingExtractor类中实现一个新方法："
}, {
  "tag": "PRE",
  "text": "    @staticmethod    def get_rating_with_count_and_reviews(r, rc, pf, bf):        if r > 10 or r < 0:            return None        else:            positive_diff = (10 - r) / 2            positive_rating = r + positive_diff            negative_diff = r / 2            negative_rating = r - negative_diff            updated_rating = ((r * rc) + (pf * positive_rating) + (bf * negative_rating)) / (rc + pf + bf)return RatingExtractor.get_rating_weight_with_quantity(updated_rating,rc,1000000,10)",
  "translation": "@staticmethod def get_rating_with_count_and_reviews（r，rc，pf，bf）：如果r> 10或r <0：返回其他值：positive_diff =（10-r）/ 2 positive_rating = r + positive_diff negative_diff = r / 2 negative_rating = r- negative_diff Updated_rating =（（（r * rc）+（pf * positive_rating）+（bf * negative_rating））/（rc + pf + bf）return RatingExtractor.get_rating_weight_with_quantity（updated_rating，rc，1000000,10）"
}, {
  "tag": "P",
  "text": "Method works as the following:",
  "translation": "方法的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["Takes r (rating), rc (rating count) pf (positive review count) and bf (negative review count) parameters", "Calculates the converted rating value for positive reviews", "Calculates the converted rating value for negative reviews", "Then calculates the updated average rating with old average rating and new rating values for each positive and negative feedback", "Then calls the method implemented in previous version with updated average rating, rating count, T = 1.000.000 (threshold) and Q=100 (rating importance parameter) and returns the result as rating contribution"],
  "translations": ["取得（正面评论计数）和bf（负面评论计数）参数的r（评分），rc（评分计数）", "计算正面评论的转换后的评分值", "计算负面评论的转换后的评分值", "然后针对每个正反馈和负反馈计算更新的平均评分，其中包含旧的平均评分和新的评分值", "然后调用具有更新的平均评分，评分计数，T = 1.000.000（阈值）和Q = 100（评分重要性参数）的先前版本中实现的方法，并将结果作为评分贡献返回"]
}, {
  "tag": "H2",
  "text": "Implementing a new method in Recommender Engine",
  "translation": "在推荐引擎中实现新方法"
}, {
  "tag": "P",
  "text": "Let’s open recommender_engine.py and add a new method to RecommenderEngine class. It is going to be similar to methods we have implemented in previous chapters, but this time we will pass positive review and negative review counts along with description, rating, rating count, threshold values:",
  "translation": "让我们打开Recommendationer_engine.py，然后向RecommenderEngine类添加一个新方法。 这将与我们在前几章中实现的方法类似，但是这次我们将传递正面评论和负面评论计数以及描述，等级，等级计数和阈值："
}, {
  "tag": "FIGURE",
  "type": "code",
  "raw": "https://gist.github.com/emrepun/384a6247eec045d6b45c5ad6c68d5641/raw/31e69236f2bc8420d3a4a97fdb1cdd6eaee0e49f/recommender_engine_version_4.py",
  "code": "# Version-4\n    def get_recommendations_include_rating_count_threshold_positive_negative_reviews(keywords):\n        df = pd.read_csv('city_data_cleared.csv')\n\n        score_dict = {}\n\n        for index, row in df.iterrows():\n            cs_score = CosineSimilarity.cosine_similarity_of(row['description'], keywords)\n\n            rating = row['rating']\n            rating_count = row['rating_count']\n            positive_review_count = row['positive_review']\n            negative_review_count = row['negative_review']\n            rating_contribution = RatingExtractor.get_rating_weight_with_count_and_reviews(rating,rating_count,positive_review_count,negative_review_count)\n\n            final_score = RecommenderEngine.calculate_final_score(cs_score, rating_contribution)\n\n            score_dict[index] = final_score\n\n        #sort cities by score and index.\n        sorted_scores = sorted(score_dict.items(), key=operator.itemgetter(1), reverse=True)\n\n        counter = 0\n\n        #create an empty results data frame.\n        resultDF = pd.DataFrame(columns=('city', 'popularity', 'description', 'score'))\n\n        #get highest scored 5 cities.\n        for i in sorted_scores:\n            #print index and score of the city.\n            #print(i[0], i[1])\n            resultDF = resultDF.append({'city': df.iloc[i[0]]['city'], 'popularity': df.iloc[i[0]]['popularity'], 'description': df.iloc[i[0]]['description'], 'score': i[1]}, ignore_index=True)\n            counter += 1\n\n            if counter>4:\n                break\n\n        #convert DF to json.\n        json_result = json.dumps(resultDF.to_dict('records'))\n        return json_result"
}, {
  "tag": "P",
  "text": "The method works as following:",
  "translation": "该方法的工作方式如下："
}, {
  "tag": "UL",
  "texts": ["Takes keywords parameter and does the following for every city in the dataset", "Computes CS score", "Gets a rating contribution weight by passing rating of the city, rating count, positive review count and negative review count. This time (T and Q parameters are passed directly from the new method in RatingExtractor class.", "Computes final score with calculate_final_score method (implemented in previous chapters) by using CS score and the rating weight.", "Gets top 5 cities with highest final score and returns as JSON"],
  "translations": ["获取关键字参数，并对数据集中的每个城市执行以下操作", "计算CS分数", "通过传递城市等级，等级数，正面评论数和负面评论数来获得等级贡献权重。 这次（T和Q参数直接从RatingExtractor类中的新方法传递。", "通过使用CS分数和等级权重，使用calculate_final_score方法（在先前的章节中实现）计算最终分数。", "获得得分最高的前5个城市，并以JSON格式返回"]
}, {
  "tag": "H2",
  "text": "Request",
  "translation": "请求"
}, {
  "tag": "P",
  "text": "We will add new requests to the request.py file to get recommendations for 3 categories with the new method",
  "translation": "我们将向request.py文件添加新请求，以使用新方法获取3个类别的建议"
}, {
  "tag": "P",
  "text": "First lets add a method to retrieve recommendations with new implementation from RecommenderEngine class:",
  "translation": "首先，让我们添加一个方法，以从RecommenderEngine类中以新的实现检索建议："
}, {
  "tag": "PRE",
  "text": "def get_recommendations_include_rating_count_threshold_positive_negative_reviews(keywords):    return RecommenderEngine.get_recommendations_include_rating_count_threshold_positive_negative_reviews(keywords)",
  "translation": "def get_recommendations_include_rating_count_threshold_positive_negative_reviews（关键字）：返回RecommenderEngine.get_recommendations_include_rating_count_threshold_positive_negative_reviews（关键字）"
}, {
  "tag": "P",
  "text": "Now let’s add new requests to get recommendations for 3 categories with the new method.",
  "translation": "现在，我们添加新请求，以使用新方法获取3个类别的推荐。"
}, {
  "tag": "PRE",
  "text": "# Version 4 requests are below:top_5_cultural_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews(culture_keywords)city_names_for_cultural_rating_count_threshold_reviews = get_top_5_city_names_out_of_json(top_5_cultural_with_rating_count_threshold_reviews)print(city_names_for_cultural_rating_count_threshold_reviews)print(\"#################\")top_5_summer_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews(beach_n_sun_keywords)city_names_for_summer_rating_count_threshold_reviews = get_top_5_city_names_out_of_json(top_5_summer_with_rating_count_threshold_reviews)print(city_names_for_summer_rating_count_threshold_reviews)print(\"#################\")top_5_party_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews(nightlife_keywords)city_names_for_party_rating_count_threshold_reviews = get_top_5_city_names_out_of_json(top_5_party_with_rating_count_threshold_reviews)print(city_names_for_party_rating_count_threshold_reviews)print(\"#################\")",
  "translation": "＃版本4请求是以下：top_5_cultural_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews（culture_keywords）city_names_for_cultural_rating_count_threshold_reviews = get_top_5_city_names_out_of_json（top_5_cultural_with_rating_count_threshold_reviews）打印（city_names_for_cultural_rating_count_threshold_reviews）打印（ “#################”）top_5_summer_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews（beach_n_sun_keywords ）city_names_for_summer_rating_count_threshold_reviews = get_top_5_city_names_out_of_json（top_5_summer_with_rating_count_threshold_reviews）打印（city_names_for_summer_rating_count_threshold_reviews）打印（ “#################”）top_5_party_with_rating_count_threshold_reviews = get_recommendations_include_rating_count_threshold_positive_negative_reviews（nightlife_keywords）city_names_for_party_rating_count_threshold_reviews = get_top_5_city_names_ou t_of_json（top_5_party_with_rating_count_threshold_reviews）print（city_names_for_party_rating_count_threshold_reviews）print（“ ##################”）"
}, {
  "tag": "P",
  "text": "The code above will fetch recommendations with their final score, you can run it and see the results you get for all the categories. I will omit the results investigation for this final chapter, as the impact of these implementations were discussed in the beginning of the post. I will just leave you the results for Culture, Art and History:",
  "translation": "上面的代码将获取建议及其最终分数，您可以运行它并查看所有类别的结果。 我将省略本最后一章的结果调查，因为在帖子的开头已讨论了这些实现的影响。 我将把关于文化，艺术和历史的结果留给您："
}, {
  "tag": "PRE",
  "text": "[('Athens', 0.2622560540924768), ('Milan', 0.2040068651858985), ('Rome', 0.16752794267650856), ('Stockholm', 0.14984473241175314), ('Barcelona', 0.14831614523091158)]",
  "translation": "[（'雅典'，0.2622560540924768），（'米兰'，0.2040068651858985），（'罗马'，0.16752794267650856），（'斯德哥尔摩'，0.14984473241175314），（'巴塞罗那'，0.14831614523091158）"
}, {
  "tag": "P",
  "text": "But I highly recommend you to investigate the results for all categories, go to chapter 3 and compare results here, what is different and why? Check the dataset to find answers, let me know if you have any questions :)",
  "translation": "但是，我强烈建议您调查所有类别的结果，转到第3章，在此处比较结果，有什么不同之处，为什么？ 检查数据集以找到答案，如果您有任何问题，请告诉我:)"
}, {
  "tag": "H1",
  "text": "Conclusion",
  "translation": "结论"
}, {
  "tag": "P",
  "text": "In this version we have implemented an approach to incorporate feedback with different forms for Recommender Systems. Our approach was to convert review feedback to rating feedback with some custom technique.",
  "translation": "在此版本中，我们实施了一种方法，以针对Recommender系统的不同形式合并反馈。 我们的方法是使用某些自定义技术将评论反馈转化为评分反馈。"
}, {
  "tag": "P",
  "text": "With this chapter, we have came to the end of Recommender System implementation. Overall, we have implemented a system to make recommendations where we know almost nothing about the users and only let them select a category (cold start problem) with an iterative approach as building on top of what we have with each chapter. I hope you have enjoyed this article, please let me know if you have any questions. Also as all these implementations were my own ideas (custom functions, formulas and techniques) they are of course not perfect and there were some trade-offs as we have seen them. So I would be happy if you can let me know how it could be improved on comments :)",
  "translation": "在本章中，我们到了推荐系统实施的结尾。 总体而言，我们已经实施了一个系统来提出建议，使我们对用户几乎一无所知，而仅让他们使用迭代方法在每个章节的基础上选择类别（冷启动问题）。 希望您喜欢这篇文章，如果您有任何疑问，请告诉我。 同样，由于所有这些实现都是我自己的想法（自定义函数，公式和技术），因此它们当然不是完美的，并且我们已经看到了一些权衡。 因此，如果您可以让我知道如何在评论中加以改进，我将非常高兴：)"
}, {
  "tag": "P",
  "text": "You can download the final version of the project here.",
  "translation": "您可以在此处下载该项目的最终版本。"
}, {
  "tag": "P",
  "text": "Cheers!",
  "translation": "干杯!"
}, {
  "tag": "H2",
  "text": "Extra",
  "translation": "额外"
}, {
  "tag": "P",
  "text": "You might be wondering why some features are not used in the dataset. As I mentioned earlier, these implementations come from my MSc project and I’ve used some of the features there when I developed a UI for mobile devices via Flutter. You can see the screenshots of the application below:",
  "translation": "您可能想知道为什么数据集中未使用某些功能。 如前所述，这些实现来自我的MSc项目，当我通过Flutter开发用于移动设备的UI时，我在其中使用了一些功能。 您可以在下面看到该应用程序的屏幕截图："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/30/1*DXtpR3S5_wiTf2HfpOO4ng.png?q=20",
  "caption": "Images from the application",
  "type": "image",
  "file": "1*DXtpR3S5_wiTf2HfpOO4ng.png"
}, {
  "tag": "P",
  "text": "Please let me know if you would be interested building a UI for the Recommender System implemented here via Flutter. Maybe I can make posts for building an app as well :)",
  "translation": "如果您有兴趣构建通过Flutter在此处实施的推荐系统的UI，请告诉我。 也许我也可以发布有关构建应用程序的帖子：）"
}, {
  "tag": "P",
  "text": "Take care!",
  "translation": "照顾自己！"
}, {
  "tag": "PRE",
  "text": "(本文翻译自Emre Havan的文章《Recommender System Application development》，参考：https://towardsdatascience.com/recommender-system-application-development-part-1-of-4-cosine-similarity-f6dbcd768e83)",
  "translation": "（本文翻译自Emre Havan的文章，《推荐系统应用程序开发》，参考：https：//towardsdatascience.com/recommender-system-application-development-part-1-of-4-cosine-similarity-f6dbcd768e83）"
}]