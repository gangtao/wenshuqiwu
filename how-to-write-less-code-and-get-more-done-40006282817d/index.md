# 最后，不要成为代码Ho积者

强迫性ard积，也称为ho积症，是一种行为模式，其特征在于过度获取和无法或不愿意丢弃覆盖住家生活区域并造成严重困扰或损害的大量物体。

而且，当开发人员成为ho积者时，即使它们存在错误或过时，他们也会坚持使用代码。 这样的开发人员通常不会删除任何代码并拒绝删除代码。 遇到问题时，您可能会得到诸如“我们可能有一天需要此代码”或“我需要此代码来执行活动X”之类的答案。

您曾经做过代码ho积者吗？ 您是否已因为没有时间清理烂摊子而放弃任何清理工作？ 如果有的话，那么您就是一个代码收藏者，而您的工作生活将是一团深重而压倒性的混乱。

积是非理性的行为。 如果您认为该代码的存在是有道理的，但是不确定，请对其进行适当标记以供以后重新使用，以便将其保留在您的雷达中。 最后，无用且不需要的代码必须删除。 期。

一个好的程序员每天都会使他们的代码越来越好。 他们的代码质量随时间而提高。 好的程序员留下的遗留代码将始终比旧代码干净。 好的程序员不要乱糟糟。 他们在代码中留下了声誉，将永远铭记在心。

正如罗伯特·马丁（Robert Martin）正确地说的那样，

“真理只能在一个地方找到：代码。”
# 避免不必要的并发

并发是一把双刃剑。 仅应在需要时使用。

当源代码按顺序执行时，代码更易于理解和调试。 使用并发时，代码可能会以并行或不规则顺序执行。 这种执行上的差异使调试代码中的问题变得非常困难。 不用说，它使程序的设计和实现复杂化的方式超过一种。 由于并发执行不当而可能发生的一些问题可能是：
+ 竞赛条件：操作会意外发生。
+ 死锁：表被锁定，等待同时完成操作。
+ 资源匮乏：永久拒绝操作访问其正在等待的资源。

世界上最臭名昭著的软件灾难之一是并发条件实施不当造成的。 Therac-25放射治疗设备发生编程错误，导致四人死亡。

也就是说，所有现代编程语言和框架都提供许多并发工具。 但是最后，这完全取决于开发人员，开发人员需要决定如何，何时以及在何处实施以获得最佳结果。
# 永远不要让您的代码更糟

这是针对开发人员的希波克拉底誓言。 作为开发人员，通常建议我们不要偷工减料，采取捷径会使代码恶化并使其恶化。

软件工程程序（例如医疗程序）可能是侵入性的，也可能是破坏性的。 同样，我们使用的工具和技术可能是新的，未经测试（或未经测试）。 而且，我们没有相当于医疗许可委员会或美国食品药品监督管理局（FDA）的机构来规范软件工程的实践和采用的工具。 因此，有时我们使“患者”（即软件）遭受不必要的风险程序，而没有真正理解风险。

在解决问题的过程中，有时弊大于利。 史蒂夫·麦康奈尔（Steve McConnell）在他的软件工程经典著作《代码完整》中说，如果您不解决问题的根本原因，而只是症状，那么弊端就是弊大于利，这是在欺骗您自己思考问题的根源。 问题已经解决。

但是，有时候这很困难。 可能是遗留代码使得很难在不损害代码的情况下正确添加功能。 现实地说，我们重申“绝不会使您的代码更糟”，改为“仅故意降级您的代码”。

是。 如果您在不降低代码质量的情况下仍无法确定如何进行更改，请在更改之前通知其他团队成员。 关键是您在故意降级代码。

当然，这不会防止不良代码，但是它给您一些时间来思考和思考。 经验表明，一个人会因为缺少愿意做的第一件事而停下来。 请注意，我们不需要征求许可，甚至不需要取得更好的结果。

另一个优点是，它可以防止在错误的时间出现令人不快的意外情况，并使团队中的每个人都意识到可以预期的问题。 然后，团队真正地以团队的方式进行排序。
# 不要编写防弹代码

防弹代码是一种完美的代码，该代码可在任何输入或意外情况下使用。

这个想法具有很大的情感吸引力，特别是对于那些热衷于开发人员的人来说，如果他们的代码在某些情况下失败，他们会认为这是个人失败。 也就是说，编写或尝试编写防弹代码是不现实且不必要的，因为这个世界上的每个对象（包括软件）都有局限性。

尝试实现一个完美的模块将涉及编写额外的条件，这将使代码更加复杂，从而消除了编写代码的目的。 该模块在适当的时候会变得更大，更昂贵，并且可能成为不良维护的潜在选择。

这就是为什么编写较少代码的经验法则应该是编写可能可行的最简单的代码。

极限编程提到了编写简单代码的两个黄金法则：
+ 首先，以您认为最可行的最简单方式实施一项新功能。 不要建造许多惊人的上层建筑，不要做任何花哨的事； 只需将其放入即可使用。 使代码通过新功能（以及所有功能，一如既往）的单元测试。
+ 其次，这对于规则至关重要，因此将系统重构为尽可能简单的代码，包括其现在具有的所有功能。 遵循OnceAndOnlyOnce规则和其他代码质量规则，以使系统尽可能干净。

永远记住，我们并不是在寻找最快的方法； 我们正在寻找最简单的结果。 因此，我们首先将现有方法分解为多个部分。 这样就可以运行现有的测试用例。 然后，我们修改（现在，简单地说）处理下一个测试用例的小方法之一，依此类推。

永远记住，极致的优雅就是简约。 控制和消除复杂性是出色编程的本质。
# 你不会需要它

YouArentGonnaNeedIt（通常缩写为YAGNI）是一种极端的编程习惯，它指出：

“总是在真正需要它们时执行它们，而永远不会仅仅在预见到需要它们时就执行。”

即使您完全，完全，完全确定以后将需要某个功能，也不要立即实施它。

练习YAGNI的主要原因有两个：
+ 您节省了时间，因为避免了编写不需要的代码。
+ 您的代码更好，因为您避免使用猜测来污染代码，这些猜测或多或少是错误的，但还是会坚持下去。

无论您使用哪种项目管理方法，YAGNI的概念都是明智的。 上乘的设计需要周全的功能平衡。 错误的设计会带来太多功能，从而造成笨拙的“维护噩梦”代码。

经验法则是，专注于明显需要的事情，而不是可能发生的事情。
## 为什么会有那么多不必要的代码？
# 如何编写更少的代码并完成更多工作。
## 代码越少，破坏，证明或维护的内容就越少
![Photo by K8 on Unsplash](0*l9TcQXtnM2XgoAzr)
> Photo by K8 on Unsplash


传奇作家儒勒·凡尔纳（Jules Verne）正确地说，

充分利用的最低要求足以满足所有需求。

在当今时代，常用的最低要求也适用于代码。 不幸的是，这是事实：在我们的现代世界中，代码太多了。 更准确地说，太多不必要的代码四处飘动，窒息了周围的好代码。

也就是说，不必要的代码本质上是不好的。 烂了 它需要定期维护。 它具有需要发现的错误。 新功能意味着必须修改旧代码。 您拥有的代码越多，隐藏错误的位置就越多。 结帐或编译花费的时间越长，新员工理解您的系统所花费的时间就越长。

除此以外，代码是由工程师生成的。 要编写更多代码，需要更多工程师。 工程师越多，通信成本就越高，这进一步增加了一篮子代码维护和开发成本。

解决所有这些问题的一种方法是编写更少的代码。

减少代码有很多好处：
+ 开发更少的代码=降低开发成本。
+ 开发更少的代码=更低的维护成本。
+ 开发更少的代码=更少的错误。
+ 开发更少的代码=更有效的测试。

最大的好处是：读取的代码越少，有人实际读取它的几率就越高。

这里有一些编写更少代码的方法。
