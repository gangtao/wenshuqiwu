[{
  "tag": "H1",
  "text": "How Do We Calculate the Fibonacci Sequence and Why Is It Important to Know It?",
  "translation": "我们如何计算斐波那契数列，为什么知道它很重要？"
}, {
  "tag": "P",
  "text": "For those of you who are new to programming, it’ll definitely help you to know how and when to use recursion or iterative functions.",
  "translation": "对于那些不熟悉编程的人来说，它无疑会帮助您了解如何以及何时使用递归或迭代函数。"
}, {
  "tag": "P",
  "text": "For mathematicians, the sequence helps them think more critically and develop their logic when starting with differential equations.",
  "translation": "对于数学家来说，该序列可帮助他们从微分方程开始时更批判性地思考并发展其逻辑。"
}, {
  "tag": "H2",
  "text": "Fibonacci’s mathematical formula",
  "translation": "斐波那契的数学公式"
}, {
  "tag": "P",
  "text": "The Fibonacci Sequence works in such a way that each number in the sequence is a sum of the two numbers that precede it.",
  "translation": "斐波那契数列的工作方式是，序列中的每个数字都是其前两个数字的和。"
}, {
  "tag": "P",
  "text": "For n=0, we have F0=0, and for n=1, we have F1=1. Remember we always have the first two values of the sequence. Our job is to figure out how the rest of the sequence is generated and what’s the result for the n value we want to check. So we always start with n>1.",
  "translation": "对于n = 0，我们有F0 = 0，对于n = 1，我们有F1 = 1。 记住，我们总是有序列的前两个值。 我们的工作是弄清楚序列的其余部分是如何生成的以及我们要检查的n值的结果是什么。 所以我们总是从n> 1开始。"
}, {
  "tag": "P",
  "text": "The Fibonacci Sequence is calculated with the formula above:",
  "translation": "斐波那契数列的计算公式如下："
}, {
  "tag": "P",
  "text": "F0=0, F1=1",
  "translation": "F0 = 0，F1 = 1"
}, {
  "tag": "P",
  "text": "Fn=Fn-1 + Fn-2 for n>1",
  "translation": "Fn = Fn-1 + Fn-2（n> 1时）"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*dwSqvPwb6P5MvOqPNzN6Zg.jpeg?q=20",
  "type": "image",
  "file": "1*dwSqvPwb6P5MvOqPNzN6Zg.jpeg"
}, {
  "tag": "P",
  "text": "Steps for calculating Fibonacci for n=6:",
  "translation": "计算n = 6的斐波那契的步骤："
}, {
  "tag": "P",
  "text": "n=0 => F0=0",
  "translation": "n = 0 => F0 = 0"
}, {
  "tag": "P",
  "text": "n=1 => F1=1",
  "translation": "n = 1 => F1 = 1"
}, {
  "tag": "P",
  "text": "n = 2 while n>1 =>F2 = F2–1 + F2–2 =F1 + F0 = 1+0=1",
  "translation": "n = 2，而n> 1 => F2 = F2-1 + F2-2 = F1 + F0 = 1 + 0 = 1"
}, {
  "tag": "P",
  "text": "n= 3 =>F3= F3–1 + F3–2 =F2 + F1=1+1 = 2",
  "translation": "n = 3 => F3 = F3-1 + F3-2 = F2 + F1 = 1 + 1 = 2"
}, {
  "tag": "P",
  "text": "n=4 =>F4=F4–1 + F4–2=F3+F2=2+1=3",
  "translation": "n = 4 => F4 = F4-1 + F4-2 = F3 + F2 = 2 + 1 = 3"
}, {
  "tag": "P",
  "text": "n=5 =>F5=F4+F3=3+2=5",
  "translation": "n = 5 => F5 = F4 + F3 = 3 + 2 = 5"
}, {
  "tag": "P",
  "text": "n=6 => F6=F5+F4=5+3=8 and so on for n>1",
  "translation": "n = 6 => F6 = F5 + F4 = 5 + 3 = 8依此类推n> 1"
}, {
  "tag": "P",
  "text": "So what will happen if we square the Fibonacci numbers?",
  "translation": "那么，如果对斐波那契数进行平方会发生什么呢？"
}, {
  "tag": "P",
  "text": "1, 1, 4, 9, 25, 65, 169, 441, …",
  "translation": "1，1，4，9，25，65，169，441，…"
}, {
  "tag": "P",
  "text": "1 + 1 + 4 =6 = 2 x 3",
  "translation": "1 +1 + 4 = 6 = 2 x 3"
}, {
  "tag": "P",
  "text": "1 + 1 + 4 + 9 =15 = 3 x 5",
  "translation": "1 +1 + 4 + 9 = 15 = 3 x 5"
}, {
  "tag": "P",
  "text": "1 + 1 +4 + 9 + 25 =40 = 5 x 8",
  "translation": "1 +1 +4 + 9 + 25 = 40 = 5 x 8"
}, {
  "tag": "P",
  "text": "1 + 1 +4 + 9 + 25 + 64 =104 = 8 x 13 …",
  "translation": "1 +1 +4 + 9 + 25 + 64 = 104 = 8 x 13…"
}, {
  "tag": "P",
  "text": "The results are not the Fibonacci numbers, but they’re buried inside the values we summed together. Which gets us thinking: Really almost every sum is a part of the Fibonacci Sequence.",
  "translation": "结果不是斐波那契数，但它们被我们汇总在一起的值所掩盖。 这让我们开始思考：实际上，几乎每个和都是斐波那契数列的一部分。"
}, {
  "tag": "P",
  "text": "Let’s check the golden rectangle and see how the Fibonacci numbers work .",
  "translation": "让我们检查一下金色矩形，看看斐波那契数字是如何工作的。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*MfNncOticBx-ctXBHoTI7Q.png?q=20",
  "type": "image",
  "file": "1*MfNncOticBx-ctXBHoTI7Q.png"
}, {
  "tag": "P",
  "text": "We all know that :",
  "translation": "我们都知道 ："
}, {
  "tag": "P",
  "text": "The area of a rectangle = b x h => b-base and h-height",
  "translation": "矩形的面积= b x h => b底和h高度"
}, {
  "tag": "P",
  "text": "So what will happen if we summed the square numbers as above?",
  "translation": "那么，如果我们将上述平方数相加会发生什么？"
}, {
  "tag": "P",
  "text": "Area of rectangle = 1² + 1² + 2²+3² +5² + 8² +13²= 273= 13x21",
  "translation": "矩形的面积=1²+1²+2²+3²+5²+8²+13²= 273 = 13x21"
}, {
  "tag": "P",
  "text": "And again we have some Fibonacci numbers.",
  "translation": "再一次，我们有一些斐波那契数。"
}, {
  "tag": "P",
  "text": "If we divide the bigger numbers with smaller numbers in the sequence, for example:",
  "translation": "如果我们按顺序将较大的数字除以较小的数字，例如："
}, {
  "tag": "P",
  "text": "13/8=1.625,21/13=1.615,34/21=1.619,",
  "translation": "13/8 = 1.625,21 / 13 = 1.615,34 / 21 = 1.619，"
}, {
  "tag": "P",
  "text": "55/34=1.6176,89/55=1.61818 …",
  "translation": "55/34 = 1.6176,89 / 55 = 1.61818…"
}, {
  "tag": "P",
  "text": "This is also known as the golden ratio or 1.618022. The larger the numbers divided, the closer we get to the value of the golden ratio.",
  "translation": "这也称为黄金分割率或1.618022。 所划分的数字越大，我们越接近黄金分割率的值。"
}, {
  "tag": "P",
  "text": "Here is a JavaScript code that calculates the Fibonacci Sequence. The time complexity is linear, as the loop runs from 2 to n. It runs in O(n) time.",
  "translation": "这是一个计算斐波纳契数列的JavaScript代码。 时间复杂度是线性的，因为循环从2到n。 它运行时间为O（n）。"
}, {
  "tag": "PRE",
  "text": "function fibonacci(n) {    var fibonacciNumbers = [],    firstNumber = 0,     secondNumber = 1;    if (n <= 0) {    return fibonacciNumbers;    }    if (n === 1) {        return fibonacciNumbers.push(firstNumber);    }    fibonacciNumbers[0] = firstNumber;    fibonacciNumbers[1] = secondNumber;    for (var i = 2; i <= n; i++) {       fibonacciNumbers[i] = fibonacciNumbers[(i — 1)] +           fibonacciNumbers[(i — 2)];   }     return fibonacciNumbers;}var result = fibonacci(3);     if(result){     for (var i = 0; i < result.length; i++) {          console.log(result[i]);    }}",
  "translation": "函数fibonacci（n）{var fibonacciNumbers = []，firstNumber = 0，secondNumber = 1； 如果（n <= 0）{返回fibonacciNumbers; }如果（n === 1）{返回fibonacciNumbers.push（firstNumber）; } fibonacciNumbers [0] = firstNumber; fibonacciNumbers [1] = secondNumber; for（var i = 2; i <= n; i ++）{ } return fibonacciNumbers;} var result = fibonacci（3）; if（result）{for（var i = 0; i <result.length; i ++）{console.log（result [i]）; }}"
}, {
  "tag": "H1",
  "text": "So What Exactly Is an Algorithm?",
  "translation": "那么究竟什么是算法？"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*luh16KeQqc7tSiTaYGsw_A.png?q=20",
  "type": "image",
  "file": "1*luh16KeQqc7tSiTaYGsw_A.png"
}, {
  "tag": "P",
  "text": "First of all, an algorithm is a set of tasks we need to follow to solve a problem. The run time of an algorithm is the total amount of steps it takes to finish those tasks (otherwise referred to as BigO notation in CS, which describes the performance of an algorithm).",
  "translation": "首先，算法是解决问题需要遵循的一组任务。 算法的运行时间是完成这些任务所需的总步数（否则称为CS中的BigO表示法，它描述算法的性能）。"
}, {
  "tag": "P",
  "text": "So what is recursion, and how does a recursive function work?",
  "translation": "那么什么是递归，递归函数如何工作？"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*yha-0-ooYsonA2kWL-fsOw.png?q=20",
  "caption": "Image by TORLEY on Flickr",
  "type": "image",
  "file": "1*yha-0-ooYsonA2kWL-fsOw.png"
}, {
  "tag": "P",
  "text": "Recursion means when something is calling itself or describing itself as a self-reference until the condition is true and it stops.",
  "translation": "递归是指某事在调用自己或将其描述为自引用之前，直到条件为真并停止。"
}, {
  "tag": "P",
  "text": "A recursive function is a function that calls itself during its execution — which is also referred to as direct recursion. The inverse of this would be when two functions call one other mutually — referred to as indirect recursion.",
  "translation": "递归函数是在执行过程中调用自身的函数，也称为直接递归。 与此相反的是，当两个函数相互调用时-称为间接递归。"
}, {
  "tag": "H1",
  "text": "The Beauty of the Fibonacci Sequence",
  "translation": "斐波那契数列之美"
}, {
  "tag": "H2",
  "text": "A basic but beautiful algorithm",
  "translation": "基本但美观的算法"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*1LsdE6AIVMPPJ9kleLNJJA.jpeg?q=20",
  "caption": "Image by Gerd Altmann on Pixabay",
  "type": "image",
  "file": "1*1LsdE6AIVMPPJ9kleLNJJA.jpeg"
}, {
  "tag": "P",
  "text": "While studying and doing research about data processing, calculation, and other related computer or mathematics operations, we come across a lot of algorithms. Even though sometimes we don’t really like math, we’re definitely surrounded with things that are sorted out really pretty in nature without even knowing it.",
  "translation": "在研究和进行有关数据处理，计算以及其他相关计算机或数学运算的研究时，我们遇到了很多算法。 即使有时候我们不太喜欢数学，但我们肯定还是被一些自然而然地整理出来的东西所包围，甚至都不知道。"
}, {
  "tag": "P",
  "text": "One of the most interesting things is to figure out how the Fibonacci sequence works. These sequences are seen a lot in everyday nature: the number of petals on a flower, the number of spirals on a sunflower, etc.",
  "translation": "最有趣的事情之一是弄清楚斐波那契数列如何工作。 这些序列在日常生活中经常出现：花朵上的花瓣数，向日葵上的螺旋数等。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*B-c95gamyPOu4pUO_e-EZA.jpeg?q=20",
  "caption": "Image by Pxfuel",
  "type": "image",
  "file": "1*B-c95gamyPOu4pUO_e-EZA.jpeg"
}, {
  "tag": "P",
  "text": "There are many different algorithms we’re going to work with while coding. While there is a ton of recursive, divide-and-conquer, randomized, and brute-force algorithms, one of the most helpful ones are the recursion ones.",
  "translation": "编码时，我们将使用许多不同的算法。 尽管有大量的递归，分而治之，随机化和蛮力算法，但最有用的算法之一就是递归算法。"
}]