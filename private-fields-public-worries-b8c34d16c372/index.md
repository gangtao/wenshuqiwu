# 私人领域，公共忧虑

JavaScript（作为一种语言）每年都在增长。 向JS引入新功能的过程可能会引起很多动荡也就不足为奇了。 程序员通常会对自己的工具持有强烈的意见，因此可以期望开发人员会不懈地讨论JS规范的任何更改。 但是，TC39委员会（负责EcmaScript标准的机构）提出的一些变更比其他变更引起了更大的阻力。 最近引起了很多负面反应的一个提议是班级领域提案，该提案除其他外试图增加语言私有班级领域。
![Giovanni Battista Bracelli from “Bizzarie di varie Figure” 1624](1*8cCm7uFoE17rmqQpgXwnhA.jpeg)
> Giovanni Battista Bracelli from “Bizzarie di varie Figure” 1624

# 提案

当前候选人的形式是结合了两个先前的提议的结果。 一个介绍公共领域，另一个提出私有类领域。 因此，该建议使我们可以在类主体内部但在构造函数之外声明类字段，并且-引入了两种类字段-公共（属性）和私有。 让我们看一些代码。
```
class BankAccount {  balance = 0;  #clientId = ‘xyz’;  deposit = (amount) => {    this.balance += amount;  };  getId = () => this.#clientId;}
```

余额是公共财产。 可以在类主体外部进行访问和修改。 如您所见，我们不需要构造函数。 我们可以直接声明公共财产。 提案的这一部分是没有争议的。 它为我们节省了一些省略构造函数的按键操作。 我想大多数使用React的开发人员都熟悉这种语法。 通常，您会看到这样定义的类组件：
```
class Widget extends React.Component {  state = {    open: false  };  toggle = () => {    this.setState(prevState => ({    open: !prevState.open    })  };  render...}
```

在此，初始状态定义为公共类字段。 但是，很容易忽略，并且切换也在使用新的类字段语法。 换句话说，toggle不是类方法，而是实例属性（因此，是的，每个Widget实例都有其自己的toggle副本）。

一切都很好，但是房间里有只白象。 是的，我正在考虑＃个字符。 这不是评论，也不是CSS ID选择器。 这是您根据提案声明私有字段的方式。 您只能在类主体内部访问此类字段。 为此，您可以编写this。＃myPrivateField或使用简写形式，并通过编写#myPrivateField完全省略此内容。
# 隐私

但是，一个字段私有是什么意思呢？ 让我们对提案的作者说：

这意味着私有字段是纯粹内部的：类之外的任何JS代码都无法检测或影响所述类实例的任何私有字段的存在，名称或值，而无需直接检查类的来源，除非该类选择显示它们 。 [私人语法常见问题]

因此，我们不仅无法访问课程之外的私有字段，而且我们也不应该知道某个班级有任何私有字段。 尝试访问这样的私有字段不会导致错误或异常。 如果是这样的话，我们将知道一个类具有这样的名称的私有字段。 该建议确保在类之外的程序的任何部分都不能以任何方式引用在类内部声明的私有字段。 语言使不可能。 如果您不在课堂上，则只能与公共字段（也就是属性）互动。
# 批评

好的，现在我们知道了建议的内容。 让我们看看用什么论点来批评该提案。
## 丑陋

我猜对私有字段语法的最常见反应可以归结为三个词（通常带有感叹号）：“这很丑”。 TC39委员会当然知道：

大多数人说请停止提议，我们无法忍受

[TC 39 2017年1月26日会议记录]

确实，这很丑。 有人声称美学不是问题而是事实，而是品味问题。 但是在这里我要说的是，我们有一个简单的美学事实：＃锡吉尔语法很丑陋。

但这是完全有效的反论点吗？ 我认为是。 即使有使用这种语法的理由（有，并且我们将讨论它们），也应考虑新语法的丑陋/美观。 丑陋的语言比美丽的语言难于使用。 所提出的语法是不直观的。 它看起来像一个注释或CSS id选择器。 该提案的作者意识到，他们的选择不是显而易见的选择。

没有人出来说：＃是表示私人状态的最美丽，最直观的东西。 相反，它更多是一个消除过程

[私人语法常见问题]

那么为什么选择＃印记呢？ 标记私有字段的最自然的候选人当然是关键字private。 为什么委员会没有选择它？ 以此方式声明私有字段将不是问题。 但是您将如何访问它？
```
class Widget {  private mySecret = '1234';}const obj = new Widget();obj.mySecret = '5689';
```

在Java中，这将导致编译错误。 但是JavaScript不是编译语言。 运行时错误？ 破坏程序的想法真糟糕，因为有人想向对象添加属性。 而且，至少根据提案作者的说法，这意味着该字段并不是真正的私有字段，因为它的作用可以从班级外部看到。
## 硬隐私

许多JS开发人员对提案的另一个方面感到不满意，即：提案拥护者对坚决的隐私保持坚守。 严格的隐私意味着无法访问甚至无法检测类之外字段的存在。 该术语与软隐私相对，后者使用户可以访问此类字段。 当然，这样的逃生舱口应该很烦人且困难，但是尽管如此，还是可以进入的。 但是，该提案的目标之一是确保JS中的私有字段是硬私有的。

它要么是完全“硬私有”（无法访问且不可观察），要么完全是公开的。

[Github讨论]

这样的说法显然是错误的。 如果这是对隐私概念的普遍理解，那么该提案的作者就无需在软性和硬性隐私之间进行区分。 软性隐私根本不应该称为隐私性...

至少有两个反论点可以用来反对严格的隐私权。 首先，在许多流行语言中，私有字段是软私有的（例如，在Java中，您可以使用反射来访问私有字段）。 因此，委员会不仅迫使非预期的语法来实现私有领域，而且还使用了非常不寻常的隐私概念。 当然，这样的论点并不能解释硬性隐私有什么问题。 它只是告诉我们这种构造不是很常见。

其次，有人可以说，无论如何都很难实现严格的隐私保护。 您始终可以使用toString方法直接查看哪些字段被声明为私有。 而且，如果toString失败了-不用担心-您现在将使用多种方法来检查任何库的源代码。 所以是的，您可以检测到一个私有字段的存在-一种或另一种方式...

但是，为什么委员会首先坚决要求坚决保护隐私呢？ 要回答这个问题，我们需要意识到该提案的主要受益者是图书馆的作者。 作为图书馆的作者，您不希望您图书馆的用户访问公共api之外的任何东西。 委员会成员认为，甚至软专用域的可检测性也可能是一个问题，因为图书馆用户可以编写条件，在这些条件下检测某些专用域会产生重要后果。

因此，这里的硬性隐私似乎真的很有用，因为它应该可以完全隐藏实施细节。 但事实并非如此。 如果需要，用户总是会找到访问此类字段的方法。 可以说，尝试这些方法的用户正在违反规则，因此，库作者不应该在意此类用户。 但是对于访问软私有字段甚至带有_前缀的属性的用户也可以这样说。 这样的开发人员还违反了与图书馆作者的合同。

但是，还有另一种说法认为硬性隐私–我认为更具说服力。 通过语言可以通过语言访问软隐私。 对于这种构造，不需要语法糖，因为在软专用字段中使用符号确实没有什么复杂的事情。 因此，如果某人不需要严格的隐私保护，他们就可以使用符号来实现柔和的隐私保护。

对该提案还有许多其他疑问。 可以肯定地说，使用硬私有字段进行调试可能会更加困难，并且猴子补丁也将更具挑战性。 但是，我只想讨论对该提案提出的另一项异议。 该异议具有更一般的性质，因此让我总结一下前面的讨论。 我要说的是，制定提案的决定所依据的理由（哈希符号，严格的隐私权）是合理的。 它们并不是最终结论，但至少它们是合乎逻辑的，并且与提案目标保持一致。 可能会有其他方式将硬私有字段引入该语言（您可以在github问题讨论中查看它们）会导致更复杂的解决方案。 标记＃使我们在声明私有字段和访问私有字段之间具有很好的对称性。 严格的隐私提供了隐藏实施细节的连贯可靠的机制。

但是也许我们只是不需要该语言的私有字段？ 在类关键字仅是语法糖的语言中引入私有字段可能不是一个好主意。 因为毕竟JS类只是原型继承上的语法糖。

我认为，对语言的这种添加可能会产生不必要的复杂语言。 因此，我不想说新语法太不直观了，以至于开发人员都会为之苦恼。 提议的语法虽然很丑陋，但却非常简单。 整体的语言可能会变得不那么简单。 毕竟，学习一种语言与学习其语法是不同的。

感谢MichałStawski，WojciechKaraś和Krzysztof Borowski。
```
(本文翻译自Filip Białek的文章《Private fields, public worries》，参考：https://medium.com/virtuslab/private-fields-public-worries-b8c34d16c372)
```
